<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<!-- saved from url=(0070)https://opensource.apple.com/source/CF/CF-635.19/CFRunLoop.c.auto.html -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>CFRunLoop.c</title>
<style type="text/css">
.enscript-comment { font-style: italic; color: rgb(178,34,34); }
.enscript-function-name { font-weight: bold; color: rgb(0,0,255); }
.enscript-variable-name { font-weight: bold; color: rgb(184,134,11); }
.enscript-keyword { font-weight: bold; color: rgb(160,32,240); }
.enscript-reference { font-weight: bold; color: rgb(95,158,160); }
.enscript-string { font-weight: bold; color: rgb(188,143,143); }
.enscript-builtin { font-weight: bold; color: rgb(218,112,214); }
.enscript-type { font-weight: bold; color: rgb(34,139,34); }
.enscript-highlight { text-decoration: underline; color: 0; }
</style>
<style type="text/css" abt="234"></style><script></script><script></script></head>
<body id="top">
<h1 style="margin:8px;" id="f1">CFRunLoop.c&nbsp;&nbsp;&nbsp;<span style="font-weight: normal; font-size: 0.5em;">[<a href="https://opensource.apple.com/source/CF/CF-635.19/CFRunLoop.c">plain text</a>]</span></h1>
<hr>
<div></div>
<pre><span class="enscript-comment">/*
 * Copyright (c) 2012 Apple Inc. All rights reserved.
 *
 * @APPLE_LICENSE_HEADER_START@
 * 
 * This file contains Original Code and/or Modifications of Original Code
 * as defined in and that are subject to the Apple Public Source License
 * Version 2.0 (the 'License'). You may not use this file except in
 * compliance with the License. Please obtain a copy of the License at
 * <a href="http://www.opensource.apple.com/apsl/">http://www.opensource.apple.com/apsl/</a> and read it before using this
 * file.
 * 
 * The Original Code and all software distributed under the License are
 * distributed on an 'AS IS' basis, WITHOUT WARRANTY OF ANY KIND, EITHER
 * EXPRESS OR IMPLIED, AND APPLE HEREBY DISCLAIMS ALL SUCH WARRANTIES,
 * INCLUDING WITHOUT LIMITATION, ANY WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, QUIET ENJOYMENT OR NON-INFRINGEMENT.
 * Please see the License for the specific language governing rights and
 * limitations under the License.
 * 
 * @APPLE_LICENSE_HEADER_END@
 */</span>

<span class="enscript-comment">/*	CFRunLoop.c
	Copyright (c) 1998-2011, Apple Inc. All rights reserved.
	Responsibility: Tony Parker
*/</span>

#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CoreFoundation/CFRunLoop.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CoreFoundation/CFSet.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CoreFoundation/CFBag.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">"CFInternal.h"</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;math.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;stdio.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;limits.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;pthread.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dispatch/dispatch.h&gt;</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;CoreFoundation/CFUserNotification.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/mach.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/clock_types.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;mach/clock.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;unistd.h&gt;</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;dlfcn.h&gt;</span>
<span class="enscript-type">extern</span> mach_port_t <span class="enscript-function-name">_dispatch_get_main_queue_port_4CF</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> <span class="enscript-type">void</span> <span class="enscript-function-name">_dispatch_main_queue_callback_4CF</span>(mach_msg_header_t *msg);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;process.h&gt;</span>
__private_extern__ LONGLONG __CFTSRToFiletime(int64_t tsr);
DISPATCH_EXPORT HANDLE <span class="enscript-function-name">_dispatch_get_main_queue_handle_4CF</span>(<span class="enscript-type">void</span>);
DISPATCH_EXPORT <span class="enscript-type">void</span> <span class="enscript-function-name">_dispatch_main_queue_callback_4CF</span>(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">include</span> <span class="enscript-string">&lt;Block.h&gt;</span>

<span class="enscript-type">static</span> <span class="enscript-type">int</span> _LogCFRunLoop = 0;

<span class="enscript-comment">// for conservative arithmetic safety, such that (TIMER_DATE_LIMIT + TIMER_INTERVAL_LIMIT + kCFAbsoluteTimeIntervalSince1970) * 10^9 &lt; 2^63
</span>#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TIMER_DATE_LIMIT</span>	4039289856.0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TIMER_INTERVAL_LIMIT</span>	504911232.0

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY</span> 0

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>

<span class="enscript-type">static</span> pthread_t kNilPthreadT = { nil, nil };
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pthreadPointer</span>(a) a.p

#<span class="enscript-reference">else</span>

<span class="enscript-type">static</span> pthread_t kNilPthreadT = (pthread_t)0;
#<span class="enscript-reference">define</span> <span class="enscript-function-name">pthreadPointer</span>(a) a
#<span class="enscript-reference">define</span> <span class="enscript-function-name">lockCount</span>(a) a
#<span class="enscript-reference">endif</span>


CF_EXPORT bool <span class="enscript-function-name">CFDictionaryGetKeyIfPresent</span>(CFDictionaryRef dict, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *key, <span class="enscript-type">const</span> <span class="enscript-type">void</span> **actualkey);

<span class="enscript-comment">// In order to reuse most of the code across Mach and Windows v1 RunLoopSources, we define a
</span><span class="enscript-comment">// simple abstraction layer spanning Mach ports and Windows HANDLES
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>

__private_extern__ uint32_t __CFGetProcessPortCount(<span class="enscript-type">void</span>) {
    ipc_info_space_t info;
    ipc_info_name_array_t table = 0;
    mach_msg_type_number_t tableCount = 0;
    ipc_info_tree_name_array_t tree = 0;
    mach_msg_type_number_t treeCount = 0;
    
    kern_return_t ret = mach_port_space_info(mach_task_self(), &amp;info, &amp;table, &amp;tableCount, &amp;tree, &amp;treeCount);
    <span class="enscript-keyword">if</span> (ret != KERN_SUCCESS) {
        <span class="enscript-keyword">return</span> (uint32_t)0;
    }
    <span class="enscript-keyword">if</span> (table != NULL) {
        ret = vm_deallocate(mach_task_self(), (vm_address_t)table, tableCount * <span class="enscript-keyword">sizeof</span>(*table));
    }
    <span class="enscript-keyword">if</span> (tree != NULL) {
        ret = vm_deallocate(mach_task_self(), (vm_address_t)tree, treeCount * <span class="enscript-keyword">sizeof</span>(*tree));
    }
    <span class="enscript-keyword">return</span> (uint32_t)tableCount;
}

__private_extern__ CFArrayRef __CFStopAllThreads(<span class="enscript-type">void</span>) {
    CFMutableArrayRef suspended_list = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, NULL);
    mach_port_t my_task = mach_task_self();
    mach_port_t my_thread = mach_thread_self();
    thread_act_array_t thr_list = 0;
    mach_msg_type_number_t thr_cnt = 0;

    <span class="enscript-comment">// really, should loop doing the stopping until no more threads get added to the list N times in a row
</span>    kern_return_t ret = task_threads(my_task, &amp;thr_list, &amp;thr_cnt);
    <span class="enscript-keyword">if</span> (ret == KERN_SUCCESS) {
        <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; thr_cnt; idx++) {
            thread_act_t thread = thr_list[idx];
            <span class="enscript-keyword">if</span> (thread == my_thread) <span class="enscript-keyword">continue</span>;
            <span class="enscript-keyword">if</span> (CFArrayContainsValue(suspended_list, CFRangeMake(0, CFArrayGetCount(suspended_list)), (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(uintptr_t)thread)) <span class="enscript-keyword">continue</span>;
            ret = thread_suspend(thread);
            <span class="enscript-keyword">if</span> (ret == KERN_SUCCESS) {
                CFArrayAppendValue(suspended_list, (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(uintptr_t)thread);
            } <span class="enscript-keyword">else</span> {
                mach_port_deallocate(my_task, thread);
            }
        }
        vm_deallocate(my_task, (vm_address_t)thr_list, <span class="enscript-keyword">sizeof</span>(thread_t) * thr_cnt);
    }
    mach_port_deallocate(my_task, my_thread);
    <span class="enscript-keyword">return</span> suspended_list;
}

__private_extern__ <span class="enscript-type">void</span> __CFRestartAllThreads(CFArrayRef threads) {
    <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; CFArrayGetCount(threads); idx++) {
        thread_act_t thread = (thread_act_t)(uintptr_t)CFArrayGetValueAtIndex(threads, idx);
        kern_return_t ret = thread_resume(thread);
        <span class="enscript-keyword">if</span> (ret != KERN_SUCCESS) HALT;
        mach_port_deallocate(mach_task_self(), thread);
    }
}

<span class="enscript-type">static</span> uint32_t __CF_last_warned_port_count = 0;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">foo</span>() __attribute__((unused));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">foo</span>() {
    uint32_t pcnt = __CFGetProcessPortCount();
    <span class="enscript-keyword">if</span> (__CF_last_warned_port_count + 1000 &lt; pcnt) {
        CFArrayRef threads = __CFStopAllThreads();


<span class="enscript-comment">// do stuff here
</span>CFOptionFlags responseFlags = 0;
SInt32 result = CFUserNotificationDisplayAlert(0.0, kCFUserNotificationCautionAlertLevel, NULL, NULL, NULL, CFSTR(<span class="enscript-string">"High Mach Port Usage"</span>), CFSTR(<span class="enscript-string">"This application is using a lot of Mach ports."</span>), CFSTR(<span class="enscript-string">"Default"</span>), CFSTR(<span class="enscript-string">"Altern"</span>), CFSTR(<span class="enscript-string">"Other b"</span>), &amp;responseFlags);
<span class="enscript-function-name">if</span> (0 != result) {
    CFLog(3, CFSTR(<span class="enscript-string">"ERROR"</span>));
} <span class="enscript-keyword">else</span> {
    <span class="enscript-keyword">switch</span> (responseFlags) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kCFUserNotificationDefaultResponse</span>: CFLog(3, CFSTR(<span class="enscript-string">"DefaultR"</span>)); <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kCFUserNotificationAlternateResponse</span>: CFLog(3, CFSTR(<span class="enscript-string">"AltR"</span>)); <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kCFUserNotificationOtherResponse</span>: CFLog(3, CFSTR(<span class="enscript-string">"OtherR"</span>)); <span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">kCFUserNotificationCancelResponse</span>: CFLog(3, CFSTR(<span class="enscript-string">"CancelR"</span>)); <span class="enscript-keyword">break</span>;
    }
}


        __CFRestartAllThreads(threads);
        CFRelease(threads);
        __CF_last_warned_port_count = pcnt;
    }
}


<span class="enscript-type">typedef</span> mach_port_t __CFPort;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CFPORT_NULL</span> MACH_PORT_NULL
<span class="enscript-type">typedef</span> mach_port_t __CFPortSet;

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__THE_SYSTEM_HAS_NO_PORTS_AVAILABLE__</span>(kern_return_t ret) __attribute__((noinline));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__THE_SYSTEM_HAS_NO_PORTS_AVAILABLE__</span>(kern_return_t ret) { HALT; };

<span class="enscript-type">static</span> __CFPort <span class="enscript-function-name">__CFPortAllocate</span>(<span class="enscript-type">void</span>) {
    __CFPort result = CFPORT_NULL;
    kern_return_t ret;
    ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_RECEIVE, &amp;result);
    <span class="enscript-keyword">if</span> (KERN_SUCCESS == ret) {
        ret = mach_port_insert_right(mach_task_self(), result, result, MACH_MSG_TYPE_MAKE_SEND);
    } <span class="enscript-keyword">else</span> {
        __THE_SYSTEM_HAS_NO_PORTS_AVAILABLE__(ret);
    }
    <span class="enscript-keyword">if</span> (KERN_SUCCESS == ret) {
        mach_port_limits_t limits;
        limits.mpl_qlimit = 1;
        ret = mach_port_set_attributes(mach_task_self(), result, MACH_PORT_LIMITS_INFO, (mach_port_info_t)&amp;limits, MACH_PORT_LIMITS_INFO_COUNT);
    }
    <span class="enscript-keyword">if</span> (KERN_SUCCESS != ret) mach_port_destroy(mach_task_self(), result);
    <span class="enscript-keyword">return</span> (KERN_SUCCESS == ret) ? result : CFPORT_NULL;
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFPortFree</span>(__CFPort port) {
    mach_port_destroy(mach_task_self(), port);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__THE_SYSTEM_HAS_NO_PORT_SETS_AVAILABLE__</span>(kern_return_t ret) __attribute__((noinline));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__THE_SYSTEM_HAS_NO_PORT_SETS_AVAILABLE__</span>(kern_return_t ret) { HALT; };

CF_INLINE __CFPortSet <span class="enscript-function-name">__CFPortSetAllocate</span>(<span class="enscript-type">void</span>) {
    __CFPortSet result;
    kern_return_t ret = mach_port_allocate(mach_task_self(), MACH_PORT_RIGHT_PORT_SET, &amp;result);
    <span class="enscript-keyword">if</span> (KERN_SUCCESS != ret) { __THE_SYSTEM_HAS_NO_PORT_SETS_AVAILABLE__(ret); }
    <span class="enscript-keyword">return</span> (KERN_SUCCESS == ret) ? result : CFPORT_NULL;
}

CF_INLINE Boolean <span class="enscript-function-name">__CFPortSetInsert</span>(__CFPort port, __CFPortSet portSet) {
    <span class="enscript-keyword">if</span> (MACH_PORT_NULL == port) {
        <span class="enscript-keyword">return</span> false;
    }
    kern_return_t ret = mach_port_insert_member(mach_task_self(), port, portSet);
    <span class="enscript-keyword">return</span> (KERN_SUCCESS == ret);
}

CF_INLINE Boolean <span class="enscript-function-name">__CFPortSetRemove</span>(__CFPort port, __CFPortSet portSet) {
    <span class="enscript-keyword">if</span> (MACH_PORT_NULL == port) {
        <span class="enscript-keyword">return</span> false;
    }
    kern_return_t ret = mach_port_extract_member(mach_task_self(), port, portSet);
    <span class="enscript-keyword">return</span> (KERN_SUCCESS == ret);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFPortSetFree</span>(__CFPortSet portSet) {
    kern_return_t ret;
    mach_port_name_array_t array;
    mach_msg_type_number_t idx, number;

    ret = mach_port_get_set_status(mach_task_self(), portSet, &amp;array, &amp;number);
    <span class="enscript-keyword">if</span> (KERN_SUCCESS == ret) {
        <span class="enscript-keyword">for</span> (idx = 0; idx &lt; number; idx++) {
            mach_port_extract_member(mach_task_self(), array[idx], portSet);
        }
        vm_deallocate(mach_task_self(), (vm_address_t)array, number * <span class="enscript-keyword">sizeof</span>(mach_port_name_t));
    }
    mach_port_destroy(mach_task_self(), portSet);
}

#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>

<span class="enscript-type">typedef</span> HANDLE __CFPort;
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">CFPORT_NULL</span> NULL

<span class="enscript-comment">// A simple dynamic array of HANDLEs, which grows to a high-water mark
</span><span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> ___CFPortSet {
    uint16_t	used;
    uint16_t	size;
    HANDLE	*handles;
    CFSpinLock_t lock;		<span class="enscript-comment">// insert and remove must be thread safe, like the Mach calls
</span>} *__CFPortSet;

CF_INLINE __CFPort <span class="enscript-function-name">__CFPortAllocate</span>(<span class="enscript-type">void</span>) {
    <span class="enscript-keyword">return</span> CreateEventA(NULL, true, false, NULL);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFPortFree</span>(__CFPort port) {
    CloseHandle(port);
}

<span class="enscript-type">static</span> __CFPortSet <span class="enscript-function-name">__CFPortSetAllocate</span>(<span class="enscript-type">void</span>) {
    __CFPortSet result = (__CFPortSet)CFAllocatorAllocate(kCFAllocatorSystemDefault, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> ___CFPortSet), 0);
    result-&gt;used = 0;
    result-&gt;size = 4;
    result-&gt;handles = (HANDLE *)CFAllocatorAllocate(kCFAllocatorSystemDefault, result-&gt;size * <span class="enscript-keyword">sizeof</span>(HANDLE), 0);
    CF_SPINLOCK_INIT_FOR_STRUCTS(result-&gt;lock);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFPortSetFree</span>(__CFPortSet portSet) {
    CFAllocatorDeallocate(kCFAllocatorSystemDefault, portSet-&gt;handles);
    CFAllocatorDeallocate(kCFAllocatorSystemDefault, portSet);
}

<span class="enscript-comment">// Returns portBuf if ports fit in that space, else returns another ptr that must be freed
</span><span class="enscript-type">static</span> __CFPort *<span class="enscript-function-name">__CFPortSetGetPorts</span>(__CFPortSet portSet, __CFPort *portBuf, uint32_t bufSize, uint32_t *portsUsed) {
    __CFSpinLock(&amp;(portSet-&gt;lock));
    __CFPort *result = portBuf;
    <span class="enscript-keyword">if</span> (bufSize &lt; portSet-&gt;used)
	result = (__CFPort *)CFAllocatorAllocate(kCFAllocatorSystemDefault, portSet-&gt;used * <span class="enscript-keyword">sizeof</span>(HANDLE), 0);
    <span class="enscript-keyword">if</span> (portSet-&gt;used &gt; 1) {
	<span class="enscript-comment">// rotate the ports to vaguely simulate round-robin behaviour
</span>	uint16_t lastPort = portSet-&gt;used - 1;
	HANDLE swapHandle = portSet-&gt;handles[0];
	memmove(portSet-&gt;handles, &amp;portSet-&gt;handles[1], lastPort * <span class="enscript-keyword">sizeof</span>(HANDLE));
	portSet-&gt;handles[lastPort] = swapHandle;
    }
    memmove(result, portSet-&gt;handles, portSet-&gt;used * <span class="enscript-keyword">sizeof</span>(HANDLE));
    *portsUsed = portSet-&gt;used;
    __CFSpinUnlock(&amp;(portSet-&gt;lock));
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFPortSetInsert</span>(__CFPort port, __CFPortSet portSet) {
    <span class="enscript-keyword">if</span> (NULL == port) {
        <span class="enscript-keyword">return</span> false;
    }
    __CFSpinLock(&amp;(portSet-&gt;lock));
    <span class="enscript-keyword">if</span> (portSet-&gt;used &gt;= portSet-&gt;size) {
        portSet-&gt;size += 4;
        portSet-&gt;handles = (HANDLE *)CFAllocatorReallocate(kCFAllocatorSystemDefault, portSet-&gt;handles, portSet-&gt;size * <span class="enscript-keyword">sizeof</span>(HANDLE), 0);
    }
    <span class="enscript-keyword">if</span> (portSet-&gt;used &gt;= MAXIMUM_WAIT_OBJECTS) {
        CFLog(kCFLogLevelWarning, CFSTR(<span class="enscript-string">"*** More than MAXIMUM_WAIT_OBJECTS (%d) ports add to a port set.  The last ones will be ignored."</span>), MAXIMUM_WAIT_OBJECTS);
    }
    portSet-&gt;handles[portSet-&gt;used++] = port;
    __CFSpinUnlock(&amp;(portSet-&gt;lock));
    <span class="enscript-keyword">return</span> true;
}

<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFPortSetRemove</span>(__CFPort port, __CFPortSet portSet) {
    <span class="enscript-type">int</span> i, j;
    <span class="enscript-keyword">if</span> (NULL == port) {
        <span class="enscript-keyword">return</span> false;
    }
    __CFSpinLock(&amp;(portSet-&gt;lock));
    <span class="enscript-keyword">for</span> (i = 0; i &lt; portSet-&gt;used; i++) {
        <span class="enscript-keyword">if</span> (portSet-&gt;handles[i] == port) {
            <span class="enscript-keyword">for</span> (j = i+1; j &lt; portSet-&gt;used; j++) {
                portSet-&gt;handles[j-1] = portSet-&gt;handles[j];
            }
            portSet-&gt;used--;
            __CFSpinUnlock(&amp;(portSet-&gt;lock));
            <span class="enscript-keyword">return</span> true;
        }
    }
    __CFSpinUnlock(&amp;(portSet-&gt;lock));
    <span class="enscript-keyword">return</span> false;
}

#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__MACTYPES__</span>) &amp;&amp; !<span class="enscript-reference">defined</span>(<span class="enscript-variable-name">_OS_OSTYPES_H</span>)
#<span class="enscript-reference">if</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__BIG_ENDIAN__</span>)
<span class="enscript-type">typedef</span>	<span class="enscript-type">struct</span> UnsignedWide {
    UInt32		hi;
    UInt32		lo;
} UnsignedWide;
#<span class="enscript-reference">elif</span> <span class="enscript-reference">defined</span>(<span class="enscript-variable-name">__LITTLE_ENDIAN__</span>)
<span class="enscript-type">typedef</span>	<span class="enscript-type">struct</span> UnsignedWide {
    UInt32		lo;
    UInt32		hi;
} UnsignedWide;
#<span class="enscript-reference">endif</span>
<span class="enscript-type">typedef</span> UnsignedWide		AbsoluteTime;
#<span class="enscript-reference">endif</span>

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
<span class="enscript-type">extern</span> mach_port_name_t <span class="enscript-function-name">mk_timer_create</span>(<span class="enscript-type">void</span>);
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">mk_timer_destroy</span>(mach_port_name_t name);
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">mk_timer_arm</span>(mach_port_name_t name, AbsoluteTime expire_time);
<span class="enscript-type">extern</span> kern_return_t <span class="enscript-function-name">mk_timer_cancel</span>(mach_port_name_t name, AbsoluteTime *result_time);

CF_INLINE AbsoluteTime <span class="enscript-function-name">__CFUInt64ToAbsoluteTime</span>(int64_t x) {
    AbsoluteTime a;
    a.hi = x &gt;&gt; 32;
    a.lo = x &amp; (int64_t)0xFFFFFFFF;
    <span class="enscript-keyword">return</span> a;
}

<span class="enscript-type">static</span> uint32_t <span class="enscript-function-name">__CFSendTrivialMachMessage</span>(mach_port_t port, uint32_t msg_id, CFOptionFlags options, uint32_t timeout) {
    kern_return_t result;
    mach_msg_header_t header;
    header.msgh_bits = MACH_MSGH_BITS(MACH_MSG_TYPE_COPY_SEND, 0);
    header.msgh_size = <span class="enscript-keyword">sizeof</span>(mach_msg_header_t);
    header.msgh_remote_port = port;
    header.msgh_local_port = MACH_PORT_NULL;
    header.msgh_id = msg_id;
    result = mach_msg(&amp;header, MACH_SEND_MSG|options, header.msgh_size, 0, MACH_PORT_NULL, timeout, MACH_PORT_NULL);
    <span class="enscript-keyword">if</span> (result == MACH_SEND_TIMED_OUT) mach_msg_destroy(&amp;header);
    <span class="enscript-keyword">return</span> result;
}
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* unlock a run loop and modes before doing callouts/sleeping */</span>
<span class="enscript-comment">/* never try to take the run loop lock with a mode locked */</span>
<span class="enscript-comment">/* be very careful of common subexpression elimination and compacting code, particular across locks and unlocks! */</span>
<span class="enscript-comment">/* run loop mode structures should never be deallocated, even if they become empty */</span>

<span class="enscript-type">static</span> CFTypeID __kCFRunLoopModeTypeID = _kCFRuntimeNotATypeID;
<span class="enscript-type">static</span> CFTypeID __kCFRunLoopTypeID = _kCFRuntimeNotATypeID;
<span class="enscript-type">static</span> CFTypeID __kCFRunLoopSourceTypeID = _kCFRuntimeNotATypeID;
<span class="enscript-type">static</span> CFTypeID __kCFRunLoopObserverTypeID = _kCFRuntimeNotATypeID;
<span class="enscript-type">static</span> CFTypeID __kCFRunLoopTimerTypeID = _kCFRuntimeNotATypeID;

<span class="enscript-type">typedef</span> <span class="enscript-type">struct</span> __CFRunLoopMode *CFRunLoopModeRef;

<span class="enscript-type">struct</span> __CFRunLoopMode {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;	<span class="enscript-comment">/* must have the run loop locked before locking this */</span>
    CFStringRef _name;
    Boolean _stopped;
    <span class="enscript-type">char</span> _padding[3];
    CFMutableSetRef _sources0;
    CFMutableSetRef _sources1;
    CFMutableArrayRef _observers;
    CFMutableArrayRef _timers;
    CFMutableDictionaryRef _portToV1SourceMap;
    __CFPortSet _portSet;
    CFIndex _observerMask;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
    mach_port_t _timerPort;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    HANDLE _timerPort;
    DWORD _msgQMask;
    <span class="enscript-type">void</span> (*_msgPump)(<span class="enscript-type">void</span>);
#<span class="enscript-reference">endif</span>
};

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopModeLock</span>(CFRunLoopModeRef rlm) {
    pthread_mutex_lock(&amp;(rlm-&gt;_lock));
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopModeLock locked %p"), rlm);
</span>}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopModeUnlock</span>(CFRunLoopModeRef rlm) {
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopModeLock unlocking %p"), rlm);
</span>    pthread_mutex_unlock(&amp;(rlm-&gt;_lock));
}

<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopModeEqual</span>(CFTypeRef cf1, CFTypeRef cf2) {
    CFRunLoopModeRef rlm1 = (CFRunLoopModeRef)cf1;
    CFRunLoopModeRef rlm2 = (CFRunLoopModeRef)cf2;
    <span class="enscript-keyword">return</span> CFEqual(rlm1-&gt;_name, rlm2-&gt;_name);
}

<span class="enscript-type">static</span> CFHashCode <span class="enscript-function-name">__CFRunLoopModeHash</span>(CFTypeRef cf) {
    CFRunLoopModeRef rlm = (CFRunLoopModeRef)cf;
    <span class="enscript-keyword">return</span> CFHash(rlm-&gt;_name);
}

<span class="enscript-type">static</span> CFStringRef <span class="enscript-function-name">__CFRunLoopModeCopyDescription</span>(CFTypeRef cf) {
    CFRunLoopModeRef rlm = (CFRunLoopModeRef)cf;
    CFMutableStringRef result;
    result = CFStringCreateMutable(kCFAllocatorSystemDefault, 0);
    CFStringAppendFormat(result, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopMode %p [%p]&gt;{name = %@, "</span>), rlm, CFGetAllocator(rlm), rlm-&gt;_name);
    CFStringAppendFormat(result, NULL, CFSTR(<span class="enscript-string">"port set = %p, "</span>), rlm-&gt;_portSet);
    CFStringAppendFormat(result, NULL, CFSTR(<span class="enscript-string">"timer port = %p, "</span>), rlm-&gt;_timerPort);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    CFStringAppendFormat(result, NULL, CFSTR(<span class="enscript-string">"MSGQ mask = %p, "</span>), rlm-&gt;_msgQMask);
#<span class="enscript-reference">endif</span>
    CFStringAppendFormat(result, NULL, CFSTR(<span class="enscript-string">"\n\tsources0 = %@,\n\tsources1 = %@,\n\tobservers = %@,\n\ttimers = %@\n},\n"</span>), rlm-&gt;_sources0, rlm-&gt;_sources1, rlm-&gt;_observers, rlm-&gt;_timers);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopModeDeallocate</span>(CFTypeRef cf) {
    CFRunLoopModeRef rlm = (CFRunLoopModeRef)cf;
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_sources0) CFRelease(rlm-&gt;_sources0);
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_sources1) CFRelease(rlm-&gt;_sources1);
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_observers) CFRelease(rlm-&gt;_observers);
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_timers) CFRelease(rlm-&gt;_timers);
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_portToV1SourceMap) CFRelease(rlm-&gt;_portToV1SourceMap);
    CFRelease(rlm-&gt;_name);
    __CFPortSetFree(rlm-&gt;_portSet);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
    <span class="enscript-keyword">if</span> (MACH_PORT_NULL != rlm-&gt;_timerPort) mk_timer_destroy(rlm-&gt;_timerPort);
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_timerPort) CloseHandle(rlm-&gt;_timerPort);
#<span class="enscript-reference">endif</span>
    pthread_mutex_destroy(&amp;rlm-&gt;_lock);
    memset((<span class="enscript-type">char</span> *)cf + <span class="enscript-keyword">sizeof</span>(CFRuntimeBase), 0x7C, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> __CFRunLoopMode) - <span class="enscript-keyword">sizeof</span>(CFRuntimeBase));
}

<span class="enscript-type">struct</span> _block_item {
    <span class="enscript-type">struct</span> _block_item *_next;
    CFTypeRef _mode;	<span class="enscript-comment">// CFString or CFSet
</span>    <span class="enscript-type">void</span> (^_block)(<span class="enscript-type">void</span>);
};

<span class="enscript-type">struct</span> __CFRunLoop {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;			<span class="enscript-comment">/* locked for accessing mode list */</span>
    __CFPort _wakeUpPort;			<span class="enscript-comment">// used for CFRunLoopWakeUp 
</span>    Boolean _ignoreWakeUps;
    <span class="enscript-type">volatile</span> uint32_t *_stopped;
    pthread_t _pthread;
    uint32_t _winthread;
    CFMutableSetRef _commonModes;
    CFMutableSetRef _commonModeItems;
    CFRunLoopModeRef _currentMode;
    CFMutableSetRef _modes;
    <span class="enscript-type">struct</span> _block_item *_blocks_head;
    <span class="enscript-type">struct</span> _block_item *_blocks_tail;
    CFTypeRef _counterpart;
};

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopDoSource1</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopSourceRef rls);
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Bit 0 of the base reserved bits is used for stopped state */</span>
<span class="enscript-comment">/* Bit 1 of the base reserved bits is used for sleeping state */</span>
<span class="enscript-comment">/* Bit 2 of the base reserved bits is used for deallocating state */</span>

CF_INLINE Boolean <span class="enscript-function-name">__CFRunLoopIsStopped</span>(CFRunLoopRef rl) {
    <span class="enscript-keyword">return</span> (rl-&gt;_stopped &amp;&amp; rl-&gt;_stopped[2]) ? true : false;
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSetStopped</span>(CFRunLoopRef rl) {
    <span class="enscript-keyword">if</span> (!rl-&gt;_stopped) {
        rl-&gt;_stopped = (uint32_t <span class="enscript-type">volatile</span> *)CFAllocatorAllocate(kCFAllocatorSystemDefault, 4 * <span class="enscript-keyword">sizeof</span>(uint32_t), 0);
        rl-&gt;_stopped[0] = 0x4346524C;
        rl-&gt;_stopped[1] = 0x4346524C; <span class="enscript-comment">// 'CFRL'
</span>        rl-&gt;_stopped[2] = 0x00000000; <span class="enscript-comment">// here the value is stored
</span>        rl-&gt;_stopped[3] = 0x4346524C;
    }
    <span class="enscript-keyword">if</span> (rl-&gt;_stopped) rl-&gt;_stopped[2] = 0x53544F50;	<span class="enscript-comment">// 'STOP'
</span>}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopUnsetStopped</span>(CFRunLoopRef rl) {
    <span class="enscript-keyword">if</span> (rl-&gt;_stopped) rl-&gt;_stopped[2] = 0x0;
}

CF_INLINE Boolean <span class="enscript-function-name">__CFRunLoopIsSleeping</span>(CFRunLoopRef rl) {
    <span class="enscript-keyword">return</span> (Boolean)__CFBitfieldGetValue(((<span class="enscript-type">const</span> CFRuntimeBase *)rl)-&gt;_cfinfo[CF_INFO_BITS], 1, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSetSleeping</span>(CFRunLoopRef rl) {
    __CFBitfieldSetValue(((CFRuntimeBase *)rl)-&gt;_cfinfo[CF_INFO_BITS], 1, 1, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopUnsetSleeping</span>(CFRunLoopRef rl) {
    __CFBitfieldSetValue(((CFRuntimeBase *)rl)-&gt;_cfinfo[CF_INFO_BITS], 1, 1, 0);
}

CF_INLINE Boolean <span class="enscript-function-name">__CFRunLoopIsDeallocating</span>(CFRunLoopRef rl) {
    <span class="enscript-keyword">return</span> (Boolean)__CFBitfieldGetValue(((<span class="enscript-type">const</span> CFRuntimeBase *)rl)-&gt;_cfinfo[CF_INFO_BITS], 2, 2);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSetDeallocating</span>(CFRunLoopRef rl) {
    __CFBitfieldSetValue(((CFRuntimeBase *)rl)-&gt;_cfinfo[CF_INFO_BITS], 2, 2, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopLock</span>(CFRunLoopRef rl) {
    pthread_mutex_lock(&amp;(((CFRunLoopRef)rl)-&gt;_lock));
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopLock locked %p"), rl);
</span>}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopUnlock</span>(CFRunLoopRef rl) {
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopLock unlocking %p"), rl);
</span>    pthread_mutex_unlock(&amp;(((CFRunLoopRef)rl)-&gt;_lock));
}

<span class="enscript-type">static</span> CFStringRef <span class="enscript-function-name">__CFRunLoopCopyDescription</span>(CFTypeRef cf) {
    CFRunLoopRef rl = (CFRunLoopRef)cf;
    CFMutableStringRef result;
    result = CFStringCreateMutable(kCFAllocatorSystemDefault, 0);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    CFStringAppendFormat(result, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoop %p [%p]&gt;{wakeup port = 0x%x, stopped = %s,\ncurrent mode = %@,\n"</span>), cf, CFGetAllocator(cf), rl-&gt;_wakeUpPort, (rl-&gt;_stopped &amp;&amp; *(rl-&gt;_stopped)) ? <span class="enscript-string">"true"</span> : <span class="enscript-string">"false"</span>, rl-&gt;_currentMode ? rl-&gt;_currentMode-&gt;_name : CFSTR(<span class="enscript-string">"(none)"</span>));
#<span class="enscript-reference">else</span>
    CFStringAppendFormat(result, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoop %p [%p]&gt;{wakeup port = 0x%x, stopped = %s,\ncurrent mode = %@,\n"</span>), cf, CFGetAllocator(cf), rl-&gt;_wakeUpPort, (rl-&gt;_stopped &amp;&amp; (rl-&gt;_stopped[2] == 0x53544F50)) ? <span class="enscript-string">"true"</span> : <span class="enscript-string">"false"</span>, rl-&gt;_currentMode ? rl-&gt;_currentMode-&gt;_name : CFSTR(<span class="enscript-string">"(none)"</span>));
#<span class="enscript-reference">endif</span>
    CFStringAppendFormat(result, NULL, CFSTR(<span class="enscript-string">"common modes = %@,\ncommon mode items = %@,\nmodes = %@}\n"</span>), rl-&gt;_commonModes, rl-&gt;_commonModeItems, rl-&gt;_modes);
    <span class="enscript-keyword">return</span> result;
}

__private_extern__ <span class="enscript-type">void</span> __CFRunLoopDump() { <span class="enscript-comment">// __private_extern__ to keep the compiler from discarding it
</span>    CFShow(CFCopyDescription(CFRunLoopGetCurrent()));
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopLockInit</span>(pthread_mutex_t *lock) {
    pthread_mutexattr_t mattr;
    pthread_mutexattr_init(&amp;mattr);
    pthread_mutexattr_settype(&amp;mattr, PTHREAD_MUTEX_RECURSIVE);
    int32_t mret = pthread_mutex_init(lock, &amp;mattr);
    pthread_mutexattr_destroy(&amp;mattr);
    <span class="enscript-keyword">if</span> (0 != mret) {
    }
}

<span class="enscript-comment">/* call with rl locked */</span>
<span class="enscript-type">static</span> CFRunLoopModeRef <span class="enscript-function-name">__CFRunLoopFindMode</span>(CFRunLoopRef rl, CFStringRef modeName, Boolean create) {
    CHECK_FOR_FORK();
    CFRunLoopModeRef rlm;
    <span class="enscript-type">struct</span> __CFRunLoopMode srlm;
    memset(&amp;srlm, 0, <span class="enscript-keyword">sizeof</span>(srlm));
    srlm._base._cfisa = __CFISAForTypeID(__kCFRunLoopModeTypeID);
    _CFRuntimeSetInstanceTypeID(&amp;srlm, __kCFRunLoopModeTypeID);
    srlm._name = modeName;
    rlm = (CFRunLoopModeRef)CFSetGetValue(rl-&gt;_modes, &amp;srlm);
    <span class="enscript-keyword">if</span> (NULL != rlm) {
	__CFRunLoopModeLock(rlm);
	<span class="enscript-keyword">return</span> rlm;
    }
    <span class="enscript-keyword">if</span> (!create) {
	<span class="enscript-keyword">return</span> NULL;
    }
    rlm = (CFRunLoopModeRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopModeTypeID, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> __CFRunLoopMode) - <span class="enscript-keyword">sizeof</span>(CFRuntimeBase), NULL);
    <span class="enscript-keyword">if</span> (NULL == rlm) {
	<span class="enscript-keyword">return</span> NULL;
    }
    __CFRunLoopLockInit(&amp;rlm-&gt;_lock);
    rlm-&gt;_name = CFStringCreateCopy(kCFAllocatorSystemDefault, modeName);
    rlm-&gt;_stopped = false;
    rlm-&gt;_portToV1SourceMap = NULL;
    rlm-&gt;_sources0 = NULL;
    rlm-&gt;_sources1 = NULL;
    rlm-&gt;_observers = NULL;
    rlm-&gt;_timers = NULL;
    rlm-&gt;_observerMask = 0;
    rlm-&gt;_portSet = __CFPortSetAllocate();
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
    rlm-&gt;_timerPort = mk_timer_create();
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    <span class="enscript-comment">// We use a manual reset timer because it is possible that we will WaitForMultipleObjectsEx on the timer port but not service it on that run loop iteration. The event is reset when we handle the timers.
</span>    rlm-&gt;_timerPort = CreateWaitableTimer(NULL, TRUE, NULL);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (!__CFPortSetInsert(rlm-&gt;_timerPort, rlm-&gt;_portSet)) HALT;
    <span class="enscript-keyword">if</span> (!__CFPortSetInsert(rl-&gt;_wakeUpPort, rlm-&gt;_portSet)) HALT;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>    
    rlm-&gt;_msgQMask = 0;
    rlm-&gt;_msgPump = NULL;
#<span class="enscript-reference">endif</span>
    CFSetAddValue(rl-&gt;_modes, rlm);
    CFRelease(rlm);
    __CFRunLoopModeLock(rlm);	<span class="enscript-comment">/* return mode locked */</span>
    <span class="enscript-keyword">return</span> rlm;
}


<span class="enscript-comment">// expects rl and rlm locked
</span><span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopModeIsEmpty</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopModeRef previousMode) {
    CHECK_FOR_FORK();
    <span class="enscript-keyword">if</span> (NULL == rlm) <span class="enscript-keyword">return</span> true;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    <span class="enscript-keyword">if</span> (0 != rlm-&gt;_msgQMask) <span class="enscript-keyword">return</span> false;
#<span class="enscript-reference">endif</span>
    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));
    <span class="enscript-keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) <span class="enscript-keyword">return</span> false; <span class="enscript-comment">// represents the libdispatch main queue
</span>    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_sources1 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources1)) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) <span class="enscript-keyword">return</span> false;
    <span class="enscript-type">struct</span> _block_item *item = rl-&gt;_blocks_head;
    <span class="enscript-keyword">while</span> (item) {
        <span class="enscript-type">struct</span> _block_item *curr = item;
        item = item-&gt;_next;
        Boolean doit = false;
        <span class="enscript-keyword">if</span> (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) {
            doit = CFEqual(curr-&gt;_mode, rlm-&gt;_name) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));
        } <span class="enscript-keyword">else</span> {
            doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, rlm-&gt;_name) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name));
        }
        <span class="enscript-keyword">if</span> (doit) <span class="enscript-keyword">return</span> false;
    }
    <span class="enscript-keyword">return</span> true;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>

uint32_t <span class="enscript-function-name">_CFRunLoopGetWindowsMessageQueueMask</span>(CFRunLoopRef rl, CFStringRef modeName) {
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	CFLog(kCFLogLevelError, CFSTR(<span class="enscript-string">"_CFRunLoopGetWindowsMessageQueueMask: kCFRunLoopCommonModes unsupported"</span>));
	HALT;
    }
    DWORD result = 0;
    __CFRunLoopLock(rl);
    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);
    <span class="enscript-keyword">if</span> (rlm) {
	result = rlm-&gt;_msgQMask;
	__CFRunLoopModeUnlock(rlm);
    }
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> (uint32_t)result;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_CFRunLoopSetWindowsMessageQueueMask</span>(CFRunLoopRef rl, uint32_t mask, CFStringRef modeName) {
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	CFLog(kCFLogLevelError, CFSTR(<span class="enscript-string">"_CFRunLoopSetWindowsMessageQueueMask: kCFRunLoopCommonModes unsupported"</span>));
	HALT;
    }
    __CFRunLoopLock(rl);
    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);
    rlm-&gt;_msgQMask = (DWORD)mask;
    __CFRunLoopModeUnlock(rlm);
    __CFRunLoopUnlock(rl);
}

uint32_t <span class="enscript-function-name">_CFRunLoopGetWindowsThreadID</span>(CFRunLoopRef rl) {
    <span class="enscript-keyword">return</span> rl-&gt;_winthread;
}

CFWindowsMessageQueueHandler <span class="enscript-function-name">_CFRunLoopGetWindowsMessageQueueHandler</span>(CFRunLoopRef rl, CFStringRef modeName) {
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	CFLog(kCFLogLevelError, CFSTR(<span class="enscript-string">"_CFRunLoopGetWindowsMessageQueueMask: kCFRunLoopCommonModes unsupported"</span>));
	HALT;
    }
    <span class="enscript-keyword">if</span> (rl != CFRunLoopGetCurrent()) {
	CFLog(kCFLogLevelError, CFSTR(<span class="enscript-string">"_CFRunLoopGetWindowsMessageQueueHandler: run loop parameter must be the current run loop"</span>));
	HALT;
    }
    <span class="enscript-type">void</span> (*result)(<span class="enscript-type">void</span>) = NULL;
    __CFRunLoopLock(rl);
    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);
    <span class="enscript-keyword">if</span> (rlm) {
	result = rlm-&gt;_msgPump;
	__CFRunLoopModeUnlock(rlm);
    }
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">_CFRunLoopSetWindowsMessageQueueHandler</span>(CFRunLoopRef rl, CFStringRef modeName, CFWindowsMessageQueueHandler func) {
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	CFLog(kCFLogLevelError, CFSTR(<span class="enscript-string">"_CFRunLoopGetWindowsMessageQueueMask: kCFRunLoopCommonModes unsupported"</span>));
	HALT;
    }
    <span class="enscript-keyword">if</span> (rl != CFRunLoopGetCurrent()) {
	CFLog(kCFLogLevelError, CFSTR(<span class="enscript-string">"_CFRunLoopGetWindowsMessageQueueHandler: run loop parameter must be the current run loop"</span>));
	HALT;
    }
    __CFRunLoopLock(rl);
    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);
    rlm-&gt;_msgPump = func;
    __CFRunLoopModeUnlock(rlm);
    __CFRunLoopUnlock(rl);
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* Bit 3 in the base reserved bits is used for invalid state in run loop objects */</span>

CF_INLINE Boolean <span class="enscript-function-name">__CFIsValid</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *cf) {
    <span class="enscript-keyword">return</span> (Boolean)__CFBitfieldGetValue(((<span class="enscript-type">const</span> CFRuntimeBase *)cf)-&gt;_cfinfo[CF_INFO_BITS], 3, 3);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFSetValid</span>(<span class="enscript-type">void</span> *cf) {
    __CFBitfieldSetValue(((CFRuntimeBase *)cf)-&gt;_cfinfo[CF_INFO_BITS], 3, 3, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFUnsetValid</span>(<span class="enscript-type">void</span> *cf) {
    __CFBitfieldSetValue(((CFRuntimeBase *)cf)-&gt;_cfinfo[CF_INFO_BITS], 3, 3, 0);
}

<span class="enscript-type">struct</span> __CFRunLoopSource {
    CFRuntimeBase _base;
    uint32_t _bits;
    pthread_mutex_t _lock;
    CFIndex _order;			<span class="enscript-comment">/* immutable */</span>
    CFMutableBagRef _runLoops;
    <span class="enscript-type">union</span> {
	CFRunLoopSourceContext version0;	<span class="enscript-comment">/* immutable, except invalidation */</span>
        CFRunLoopSourceContext1 version1;	<span class="enscript-comment">/* immutable, except invalidation */</span>
    } _context;
};

<span class="enscript-comment">/* Bit 1 of the base reserved bits is used for signalled state */</span>

CF_INLINE Boolean <span class="enscript-function-name">__CFRunLoopSourceIsSignaled</span>(CFRunLoopSourceRef rls) {
    <span class="enscript-keyword">return</span> (Boolean)__CFBitfieldGetValue(rls-&gt;_bits, 1, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSourceSetSignaled</span>(CFRunLoopSourceRef rls) {
    __CFBitfieldSetValue(rls-&gt;_bits, 1, 1, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSourceUnsetSignaled</span>(CFRunLoopSourceRef rls) {
    __CFBitfieldSetValue(rls-&gt;_bits, 1, 1, 0);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSourceLock</span>(CFRunLoopSourceRef rls) {
    pthread_mutex_lock(&amp;(rls-&gt;_lock));
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopSourceLock locked %p"), rls);
</span>}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSourceUnlock</span>(CFRunLoopSourceRef rls) {
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopSourceLock unlocking %p"), rls);
</span>    pthread_mutex_unlock(&amp;(rls-&gt;_lock));
}


<span class="enscript-type">struct</span> __CFRunLoopObserver {
    CFRuntimeBase _base;
    pthread_mutex_t _lock;
    CFRunLoopRef _runLoop;
    CFIndex _rlCount;
    CFOptionFlags _activities;		<span class="enscript-comment">/* immutable */</span>
    CFIndex _order;			<span class="enscript-comment">/* immutable */</span>
    CFRunLoopObserverCallBack _callout;	<span class="enscript-comment">/* immutable */</span>
    CFRunLoopObserverContext _context;	<span class="enscript-comment">/* immutable, except invalidation */</span>
};

<span class="enscript-comment">/* Bit 0 of the base reserved bits is used for firing state */</span>
<span class="enscript-comment">/* Bit 1 of the base reserved bits is used for repeats state */</span>

CF_INLINE Boolean <span class="enscript-function-name">__CFRunLoopObserverIsFiring</span>(CFRunLoopObserverRef rlo) {
    <span class="enscript-keyword">return</span> (Boolean)__CFBitfieldGetValue(((<span class="enscript-type">const</span> CFRuntimeBase *)rlo)-&gt;_cfinfo[CF_INFO_BITS], 0, 0);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopObserverSetFiring</span>(CFRunLoopObserverRef rlo) {
    __CFBitfieldSetValue(((CFRuntimeBase *)rlo)-&gt;_cfinfo[CF_INFO_BITS], 0, 0, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopObserverUnsetFiring</span>(CFRunLoopObserverRef rlo) {
    __CFBitfieldSetValue(((CFRuntimeBase *)rlo)-&gt;_cfinfo[CF_INFO_BITS], 0, 0, 0);
}

CF_INLINE Boolean <span class="enscript-function-name">__CFRunLoopObserverRepeats</span>(CFRunLoopObserverRef rlo) {
    <span class="enscript-keyword">return</span> (Boolean)__CFBitfieldGetValue(((<span class="enscript-type">const</span> CFRuntimeBase *)rlo)-&gt;_cfinfo[CF_INFO_BITS], 1, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopObserverSetRepeats</span>(CFRunLoopObserverRef rlo) {
    __CFBitfieldSetValue(((CFRuntimeBase *)rlo)-&gt;_cfinfo[CF_INFO_BITS], 1, 1, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopObserverUnsetRepeats</span>(CFRunLoopObserverRef rlo) {
    __CFBitfieldSetValue(((CFRuntimeBase *)rlo)-&gt;_cfinfo[CF_INFO_BITS], 1, 1, 0);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopObserverLock</span>(CFRunLoopObserverRef rlo) {
    pthread_mutex_lock(&amp;(rlo-&gt;_lock));
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopObserverLock locked %p"), rlo);
</span>}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopObserverUnlock</span>(CFRunLoopObserverRef rlo) {
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopObserverLock unlocking %p"), rlo);
</span>    pthread_mutex_unlock(&amp;(rlo-&gt;_lock));
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopObserverSchedule</span>(CFRunLoopObserverRef rlo, CFRunLoopRef rl, CFRunLoopModeRef rlm) {
    __CFRunLoopObserverLock(rlo);
    <span class="enscript-keyword">if</span> (0 == rlo-&gt;_rlCount) {
	rlo-&gt;_runLoop = rl;
    }
    rlo-&gt;_rlCount++;
    __CFRunLoopObserverUnlock(rlo);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopObserverCancel</span>(CFRunLoopObserverRef rlo, CFRunLoopRef rl, CFRunLoopModeRef rlm) {
    __CFRunLoopObserverLock(rlo);
    rlo-&gt;_rlCount--;
    <span class="enscript-keyword">if</span> (0 == rlo-&gt;_rlCount) {
	rlo-&gt;_runLoop = NULL;
    }
    __CFRunLoopObserverUnlock(rlo);
}

<span class="enscript-type">struct</span> __CFRunLoopTimer {
    CFRuntimeBase _base;
    uint16_t _bits;
    pthread_mutex_t _lock;
    CFRunLoopRef _runLoop;
    CFMutableSetRef _rlModes;
    CFAbsoluteTime _nextFireDate;
    CFTimeInterval _interval;		<span class="enscript-comment">/* immutable */</span>
    int64_t _fireTSR;			<span class="enscript-comment">/* TSR units */</span>
    CFIndex _order;			<span class="enscript-comment">/* immutable */</span>
    CFRunLoopTimerCallBack _callout;	<span class="enscript-comment">/* immutable */</span>
    CFRunLoopTimerContext _context;	<span class="enscript-comment">/* immutable, except invalidation */</span>
};

<span class="enscript-comment">/* Bit 0 of the base reserved bits is used for firing state */</span>
<span class="enscript-comment">/* Bit 1 of the base reserved bits is used for fired-during-callout state */</span>

CF_INLINE Boolean <span class="enscript-function-name">__CFRunLoopTimerIsFiring</span>(CFRunLoopTimerRef rlt) {
    <span class="enscript-keyword">return</span> (Boolean)__CFBitfieldGetValue(rlt-&gt;_bits, 0, 0);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimerSetFiring</span>(CFRunLoopTimerRef rlt) {
    __CFBitfieldSetValue(rlt-&gt;_bits, 0, 0, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimerUnsetFiring</span>(CFRunLoopTimerRef rlt) {
    __CFBitfieldSetValue(rlt-&gt;_bits, 0, 0, 0);
}

CF_INLINE Boolean <span class="enscript-function-name">__CFRunLoopTimerIsDeallocating</span>(CFRunLoopTimerRef rlt) {
    <span class="enscript-keyword">return</span> (Boolean)__CFBitfieldGetValue(rlt-&gt;_bits, 2, 2);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimerSetDeallocating</span>(CFRunLoopTimerRef rlt) {
    __CFBitfieldSetValue(rlt-&gt;_bits, 2, 2, 1);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimerLock</span>(CFRunLoopTimerRef rlt) {
    pthread_mutex_lock(&amp;(rlt-&gt;_lock));
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopTimerLock locked %p"), rlt);
</span>}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimerUnlock</span>(CFRunLoopTimerRef rlt) {
<span class="enscript-comment">//    CFLog(6, CFSTR("__CFRunLoopTimerLock unlocking %p"), rlt);
</span>    pthread_mutex_unlock(&amp;(rlt-&gt;_lock));
}

<span class="enscript-type">static</span> CFSpinLock_t __CFRLTFireTSRLock = CFSpinLockInit;

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimerFireTSRLock</span>(<span class="enscript-type">void</span>) {
    __CFSpinLock(&amp;__CFRLTFireTSRLock);
}

CF_INLINE <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimerFireTSRUnlock</span>(<span class="enscript-type">void</span>) {
    __CFSpinUnlock(&amp;__CFRLTFireTSRLock);
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>

<span class="enscript-type">struct</span> _collectTimersContext {
    CFMutableArrayRef results;
    int64_t cutoffTSR;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopCollectTimers</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *ctx) {
    CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)value;
    <span class="enscript-type">struct</span> _collectTimersContext *context = (<span class="enscript-type">struct</span> _collectTimersContext *)ctx;
    <span class="enscript-keyword">if</span> (rlt-&gt;_fireTSR &lt;= context-&gt;cutoffTSR) {
        <span class="enscript-keyword">if</span> (NULL == context-&gt;results)
            context-&gt;results = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);
        CFArrayAppendValue(context-&gt;results, rlt);
    }
}

<span class="enscript-comment">// RunLoop and RunLoopMode must be locked
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimersToFireRecursive</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, <span class="enscript-type">struct</span> _collectTimersContext *ctxt) {
    __CFRunLoopTimerFireTSRLock();
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) {
        CFArrayApplyFunction(rlm-&gt;_timers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_timers)),  __CFRunLoopCollectTimers, ctxt);
    }
    __CFRunLoopTimerFireTSRUnlock();
}

<span class="enscript-comment">// RunLoop and RunLoopMode must be locked
</span><span class="enscript-type">static</span> CFArrayRef <span class="enscript-function-name">__CFRunLoopTimersToFire</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm) {
    <span class="enscript-type">struct</span> _collectTimersContext ctxt = {NULL, mach_absolute_time()};
    __CFRunLoopTimersToFireRecursive(rl, rlm, &amp;ctxt);
    <span class="enscript-keyword">return</span> ctxt.results;
}

#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* CFRunLoop */</span>

<span class="enscript-function-name">CONST_STRING_DECL</span>(kCFRunLoopDefaultMode, <span class="enscript-string">"kCFRunLoopDefaultMode"</span>)
<span class="enscript-function-name">CONST_STRING_DECL</span>(kCFRunLoopCommonModes, <span class="enscript-string">"kCFRunLoopCommonModes"</span>)

<span class="enscript-comment">// call with rl and rlm locked
</span><span class="enscript-type">static</span> CFRunLoopSourceRef <span class="enscript-function-name">__CFRunLoopModeFindSourceForMachPort</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, __CFPort port) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();
    CFRunLoopSourceRef found = rlm-&gt;_portToV1SourceMap ? (CFRunLoopSourceRef)CFDictionaryGetValue(rlm-&gt;_portToV1SourceMap, (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(uintptr_t)port) : NULL;
    <span class="enscript-keyword">return</span> found;
}

<span class="enscript-comment">// Remove backreferences the mode's sources have to the rl (context);
</span><span class="enscript-comment">// the primary purpose of rls-&gt;_runLoops is so that Invalidation can remove
</span><span class="enscript-comment">// the source from the run loops it is in, but during deallocation of a
</span><span class="enscript-comment">// run loop, we already know that the sources are going to be punted
</span><span class="enscript-comment">// from it, so invalidation of sources does not need to remove from a
</span><span class="enscript-comment">// deallocating run loop.
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopCleanseSources</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *context) {
    CFRunLoopModeRef rlm = (CFRunLoopModeRef)value;
    CFRunLoopRef rl = (CFRunLoopRef)context;
    CFIndex idx, cnt;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> **list, *buffer[256];
    <span class="enscript-keyword">if</span> (NULL == rlm-&gt;_sources0 &amp;&amp; NULL == rlm-&gt;_sources1) <span class="enscript-keyword">return</span>;

    cnt = (rlm-&gt;_sources0 ? CFSetGetCount(rlm-&gt;_sources0) : 0) + (rlm-&gt;_sources1 ? CFSetGetCount(rlm-&gt;_sources1) : 0);
    list = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **)((cnt &lt;= 256) ? buffer : CFAllocatorAllocate(kCFAllocatorSystemDefault, cnt * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *), 0));
    <span class="enscript-keyword">if</span> (rlm-&gt;_sources0) CFSetGetValues(rlm-&gt;_sources0, list);
    <span class="enscript-keyword">if</span> (rlm-&gt;_sources1) CFSetGetValues(rlm-&gt;_sources1, list + (rlm-&gt;_sources0 ? CFSetGetCount(rlm-&gt;_sources0) : 0));
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; cnt; idx++) {
	CFRunLoopSourceRef rls = (CFRunLoopSourceRef)list[idx];
	__CFRunLoopSourceLock(rls);
	<span class="enscript-keyword">if</span> (NULL != rls-&gt;_runLoops) {
	    CFBagRemoveValue(rls-&gt;_runLoops, rl);
	}
	__CFRunLoopSourceUnlock(rls);
    }
    <span class="enscript-keyword">if</span> (list != buffer) CFAllocatorDeallocate(kCFAllocatorSystemDefault, list);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopDeallocateSources</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *context) {
    CFRunLoopModeRef rlm = (CFRunLoopModeRef)value;
    CFRunLoopRef rl = (CFRunLoopRef)context;
    CFIndex idx, cnt;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> **list, *buffer[256];
    <span class="enscript-keyword">if</span> (NULL == rlm-&gt;_sources0 &amp;&amp; NULL == rlm-&gt;_sources1) <span class="enscript-keyword">return</span>;

    cnt = (rlm-&gt;_sources0 ? CFSetGetCount(rlm-&gt;_sources0) : 0) + (rlm-&gt;_sources1 ? CFSetGetCount(rlm-&gt;_sources1) : 0);
    list = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **)((cnt &lt;= 256) ? buffer : CFAllocatorAllocate(kCFAllocatorSystemDefault, cnt * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *), 0));
    <span class="enscript-keyword">if</span> (rlm-&gt;_sources0) CFSetGetValues(rlm-&gt;_sources0, list);
    <span class="enscript-keyword">if</span> (rlm-&gt;_sources1) CFSetGetValues(rlm-&gt;_sources1, list + (rlm-&gt;_sources0 ? CFSetGetCount(rlm-&gt;_sources0) : 0));
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; cnt; idx++) {
	CFRetain(list[idx]);
    }
    <span class="enscript-keyword">if</span> (rlm-&gt;_sources0) CFSetRemoveAllValues(rlm-&gt;_sources0);
    <span class="enscript-keyword">if</span> (rlm-&gt;_sources1) CFSetRemoveAllValues(rlm-&gt;_sources1);
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; cnt; idx++) {
        CFRunLoopSourceRef rls = (CFRunLoopSourceRef)list[idx];
        __CFRunLoopSourceLock(rls);
        <span class="enscript-keyword">if</span> (NULL != rls-&gt;_runLoops) {
            CFBagRemoveValue(rls-&gt;_runLoops, rl);
        }
        __CFRunLoopSourceUnlock(rls);
        <span class="enscript-keyword">if</span> (0 == rls-&gt;_context.version0.version) {
            <span class="enscript-keyword">if</span> (NULL != rls-&gt;_context.version0.cancel) {
                rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, rlm-&gt;_name);	<span class="enscript-comment">/* CALLOUT */</span>
            }
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (1 == rls-&gt;_context.version0.version) {
            __CFPort port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);	<span class="enscript-comment">/* CALLOUT */</span>
            <span class="enscript-keyword">if</span> (CFPORT_NULL != port) {
                __CFPortSetRemove(port, rlm-&gt;_portSet);
            }
        }
	CFRelease(rls);
    }
    <span class="enscript-keyword">if</span> (list != buffer) CFAllocatorDeallocate(kCFAllocatorSystemDefault, list);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopDeallocateObservers</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *context) {
    CFRunLoopModeRef rlm = (CFRunLoopModeRef)value;
    CFRunLoopRef rl = (CFRunLoopRef)context;
    CFIndex idx, cnt;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> **list, *buffer[256];
    <span class="enscript-keyword">if</span> (NULL == rlm-&gt;_observers) <span class="enscript-keyword">return</span>;
    cnt = CFArrayGetCount(rlm-&gt;_observers);
    list = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **)((cnt &lt;= 256) ? buffer : CFAllocatorAllocate(kCFAllocatorSystemDefault, cnt * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *), 0));
    CFArrayGetValues(rlm-&gt;_observers, CFRangeMake(0, cnt), list);
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; cnt; idx++) {
	CFRetain(list[idx]);
    }
    CFArrayRemoveAllValues(rlm-&gt;_observers);
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; cnt; idx++) {
	__CFRunLoopObserverCancel((CFRunLoopObserverRef)list[idx], rl, rlm);
	CFRelease(list[idx]);
    }
    <span class="enscript-keyword">if</span> (list != buffer) CFAllocatorDeallocate(kCFAllocatorSystemDefault, list);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopDeallocateTimers</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *context) {
    CFRunLoopModeRef rlm = (CFRunLoopModeRef)value;
    CFIndex idx, cnt;
    <span class="enscript-type">const</span> <span class="enscript-type">void</span> **list, *buffer[256];
    <span class="enscript-keyword">if</span> (NULL == rlm-&gt;_timers) <span class="enscript-keyword">return</span>;
    cnt = CFArrayGetCount(rlm-&gt;_timers);
    list = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **)((cnt &lt;= 256) ? buffer : CFAllocatorAllocate(kCFAllocatorSystemDefault, cnt * <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">void</span> *), 0));
    CFArrayGetValues(rlm-&gt;_timers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_timers)), list);
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; cnt; idx++) {
	CFRetain(list[idx]);
    }
    CFArrayRemoveAllValues(rlm-&gt;_timers);
    <span class="enscript-keyword">for</span> (idx = 0; idx &lt; cnt; idx++) {
        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)list[idx];
        __CFRunLoopTimerLock(rlt);
        <span class="enscript-comment">// if the run loop is deallocating, and since a timer can only be in one
</span>        <span class="enscript-comment">// run loop, we're going to be removing the timer from all modes, so be
</span>        <span class="enscript-comment">// a little heavy-handed and direct
</span>        CFSetRemoveAllValues(rlt-&gt;_rlModes);
        rlt-&gt;_runLoop = NULL;
        __CFRunLoopTimerUnlock(rlt);
	CFRelease(list[idx]);
    }
    <span class="enscript-keyword">if</span> (list != buffer) CFAllocatorDeallocate(kCFAllocatorSystemDefault, list);
}

CF_EXPORT pthread_t _CFMainPThread;
CF_EXPORT CFRunLoopRef <span class="enscript-function-name">_CFRunLoopGet0b</span>(pthread_t t);

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopDeallocate</span>(CFTypeRef cf) {
    CFRunLoopRef rl = (CFRunLoopRef)cf;

    <span class="enscript-keyword">if</span> (_CFRunLoopGet0b(_CFMainPThread) == cf) HALT;

    <span class="enscript-comment">/* We try to keep the run loop in a valid state as long as possible,
       since sources may have non-retained references to the run loop.
       Another reason is that we don't want to lock the run loop for
       callback reasons, if we can get away without that.  We start by
       eliminating the sources, since they are the most likely to call
       back into the run loop during their "cancellation". Common mode
       items will be removed from the mode indirectly by the following
       three lines. */</span>
    __CFRunLoopSetDeallocating(rl);
    <span class="enscript-keyword">if</span> (NULL != rl-&gt;_modes) {
	CFSetApplyFunction(rl-&gt;_modes, (__CFRunLoopCleanseSources), rl); <span class="enscript-comment">// remove references to rl
</span>	CFSetApplyFunction(rl-&gt;_modes, (__CFRunLoopDeallocateSources), rl);
	CFSetApplyFunction(rl-&gt;_modes, (__CFRunLoopDeallocateObservers), rl);
	CFSetApplyFunction(rl-&gt;_modes, (__CFRunLoopDeallocateTimers), rl);
    }
    __CFRunLoopLock(rl);
    <span class="enscript-type">struct</span> _block_item *item = rl-&gt;_blocks_head;
    <span class="enscript-keyword">while</span> (item) {
	<span class="enscript-type">struct</span> _block_item *curr = item;
	item = item-&gt;_next;
	CFRelease(curr-&gt;_mode);
	Block_release(curr-&gt;_block);
	free(curr);
    }
    <span class="enscript-keyword">if</span> (NULL != rl-&gt;_commonModeItems) {
	CFRelease(rl-&gt;_commonModeItems);
    }
    <span class="enscript-keyword">if</span> (NULL != rl-&gt;_commonModes) {
	CFRelease(rl-&gt;_commonModes);
    }
    <span class="enscript-keyword">if</span> (NULL != rl-&gt;_modes) {
	CFRelease(rl-&gt;_modes);
    }
    __CFPortFree(rl-&gt;_wakeUpPort);
    rl-&gt;_wakeUpPort = CFPORT_NULL;
    __CFRunLoopUnlock(rl);
    pthread_mutex_destroy(&amp;rl-&gt;_lock);
    memset((<span class="enscript-type">char</span> *)cf + <span class="enscript-keyword">sizeof</span>(CFRuntimeBase), 0x8C, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> __CFRunLoop) - <span class="enscript-keyword">sizeof</span>(CFRuntimeBase));
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> CFRuntimeClass __CFRunLoopModeClass = {
    0,
    <span class="enscript-string">"CFRunLoopMode"</span>,
    NULL,      <span class="enscript-comment">// init
</span>    NULL,      <span class="enscript-comment">// copy
</span>    __CFRunLoopModeDeallocate,
    __CFRunLoopModeEqual,
    __CFRunLoopModeHash,
    NULL,      <span class="enscript-comment">// 
</span>    __CFRunLoopModeCopyDescription
};

<span class="enscript-type">static</span> <span class="enscript-type">const</span> CFRuntimeClass __CFRunLoopClass = {
    0,
    <span class="enscript-string">"CFRunLoop"</span>,
    NULL,      <span class="enscript-comment">// init
</span>    NULL,      <span class="enscript-comment">// copy
</span>    __CFRunLoopDeallocate,
    NULL,
    NULL,
    NULL,      <span class="enscript-comment">// 
</span>    __CFRunLoopCopyDescription
};

__private_extern__ <span class="enscript-type">void</span> __CFFinalizeRunLoop(uintptr_t data);

<span class="enscript-type">static</span> int64_t tenus = 0LL;

__private_extern__ <span class="enscript-type">void</span> __CFRunLoopInitialize(<span class="enscript-type">void</span>) {
    tenus = __CFTimeIntervalToTSR(0.000010000);
    __kCFRunLoopTypeID = _CFRuntimeRegisterClass(&amp;__CFRunLoopClass);
    __kCFRunLoopModeTypeID = _CFRuntimeRegisterClass(&amp;__CFRunLoopModeClass);
}
 
CFTypeID <span class="enscript-function-name">CFRunLoopGetTypeID</span>(<span class="enscript-type">void</span>) {
    <span class="enscript-keyword">return</span> __kCFRunLoopTypeID;
}

<span class="enscript-type">static</span> CFRunLoopRef <span class="enscript-function-name">__CFRunLoopCreate</span>(pthread_t t) {
    CFRunLoopRef loop = NULL;
    CFRunLoopModeRef rlm;
    uint32_t size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> __CFRunLoop) - <span class="enscript-keyword">sizeof</span>(CFRuntimeBase);
    loop = (CFRunLoopRef)_CFRuntimeCreateInstance(kCFAllocatorSystemDefault, __kCFRunLoopTypeID, size, NULL);
    <span class="enscript-keyword">if</span> (NULL == loop) {
	<span class="enscript-keyword">return</span> NULL;
    }
    loop-&gt;_stopped = NULL;
    __CFRunLoopLockInit(&amp;loop-&gt;_lock);
    loop-&gt;_wakeUpPort = __CFPortAllocate();
    <span class="enscript-keyword">if</span> (CFPORT_NULL == loop-&gt;_wakeUpPort) HALT;
    loop-&gt;_ignoreWakeUps = true;
    loop-&gt;_commonModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
    CFSetAddValue(loop-&gt;_commonModes, kCFRunLoopDefaultMode);
    loop-&gt;_commonModeItems = NULL;
    loop-&gt;_currentMode = NULL;
    loop-&gt;_modes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
    loop-&gt;_blocks_head = NULL;
    loop-&gt;_blocks_tail = NULL;
    loop-&gt;_counterpart = NULL;
    loop-&gt;_pthread = t;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    loop-&gt;_winthread = GetCurrentThreadId();
#<span class="enscript-reference">else</span>
    loop-&gt;_winthread = 0;
#<span class="enscript-reference">endif</span>
    rlm = __CFRunLoopFindMode(loop, kCFRunLoopDefaultMode, true);
    <span class="enscript-keyword">if</span> (NULL != rlm) __CFRunLoopModeUnlock(rlm);
    <span class="enscript-keyword">return</span> loop;
}

<span class="enscript-type">static</span> CFMutableDictionaryRef __CFRunLoops = NULL;
<span class="enscript-type">static</span> CFSpinLock_t loopsLock = CFSpinLockInit;

<span class="enscript-comment">// should only be called by Foundation
</span><span class="enscript-comment">// t==0 is a synonym for "main thread" that always works
</span>CF_EXPORT CFRunLoopRef <span class="enscript-function-name">_CFRunLoopGet0</span>(pthread_t t) {
    <span class="enscript-keyword">if</span> (pthread_equal(t, kNilPthreadT)) {
	t = _CFMainPThread;
    }
    __CFSpinLock(&amp;loopsLock);
    <span class="enscript-keyword">if</span> (!__CFRunLoops) {
        __CFSpinUnlock(&amp;loopsLock);
	CFMutableDictionaryRef dict = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, &amp;kCFTypeDictionaryValueCallBacks);
	CFRunLoopRef mainLoop = __CFRunLoopCreate(_CFMainPThread);
	CFDictionarySetValue(dict, pthreadPointer(_CFMainPThread), mainLoop);
	<span class="enscript-keyword">if</span> (!OSAtomicCompareAndSwapPtrBarrier(NULL, dict, (<span class="enscript-type">void</span> * <span class="enscript-type">volatile</span> *)&amp;__CFRunLoops)) {
	    CFRelease(dict);
	}
	CFRelease(mainLoop);
        __CFSpinLock(&amp;loopsLock);
    }
    CFRunLoopRef loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
    <span class="enscript-keyword">if</span> (!loop) {
        __CFSpinUnlock(&amp;loopsLock);
	CFRunLoopRef newLoop = __CFRunLoopCreate(t);
        __CFSpinLock(&amp;loopsLock);
	loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
	<span class="enscript-keyword">if</span> (!loop) {
	    CFDictionarySetValue(__CFRunLoops, pthreadPointer(t), newLoop);
	    loop = newLoop;
	}
	CFRelease(newLoop);
    }
    <span class="enscript-keyword">if</span> (pthread_equal(t, pthread_self())) {
        _CFSetTSD(__CFTSDKeyRunLoop, (<span class="enscript-type">void</span> *)loop, NULL);
        <span class="enscript-keyword">if</span> (0 == _CFGetTSD(__CFTSDKeyRunLoopCntr)) {
            _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="enscript-type">void</span> *)(PTHREAD_DESTRUCTOR_ITERATIONS-1), (<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *))__CFFinalizeRunLoop);
        }
    }
    __CFSpinUnlock(&amp;loopsLock);
    <span class="enscript-keyword">return</span> loop;
}

<span class="enscript-comment">// should only be called by Foundation
</span>CFRunLoopRef <span class="enscript-function-name">_CFRunLoopGet0b</span>(pthread_t t) {
    <span class="enscript-keyword">if</span> (pthread_equal(t, kNilPthreadT)) {
	t = _CFMainPThread;
    }
    __CFSpinLock(&amp;loopsLock);
    CFRunLoopRef loop = NULL;
    <span class="enscript-keyword">if</span> (__CFRunLoops) {
        loop = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(t));
    }
    __CFSpinUnlock(&amp;loopsLock);
    <span class="enscript-keyword">return</span> loop;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopRemoveAllSources</span>(CFRunLoopRef rl, CFStringRef modeName);

<span class="enscript-comment">// Called for each thread as it exits
</span>__private_extern__ <span class="enscript-type">void</span> __CFFinalizeRunLoop(uintptr_t data) {
    CFRunLoopRef rl = NULL;
    <span class="enscript-keyword">if</span> (data &lt;= 1) {
	__CFSpinLock(&amp;loopsLock);
	<span class="enscript-keyword">if</span> (__CFRunLoops) {
	    rl = (CFRunLoopRef)CFDictionaryGetValue(__CFRunLoops, pthreadPointer(pthread_self()));
	    <span class="enscript-keyword">if</span> (rl) CFRetain(rl);
	    CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));
	}
	__CFSpinUnlock(&amp;loopsLock);
    } <span class="enscript-keyword">else</span> {
        _CFSetTSD(__CFTSDKeyRunLoopCntr, (<span class="enscript-type">void</span> *)(data - 1), (<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *))__CFFinalizeRunLoop);
    }
    <span class="enscript-keyword">if</span> (rl &amp;&amp; CFRunLoopGetMain() != rl) { <span class="enscript-comment">// protect against cooperative threads
</span>        <span class="enscript-keyword">if</span> (NULL != rl-&gt;_counterpart) {
            CFRelease(rl-&gt;_counterpart);
	    rl-&gt;_counterpart = NULL;
        }
	<span class="enscript-comment">// purge all sources before deallocation
</span>        CFArrayRef array = CFRunLoopCopyAllModes(rl);
        <span class="enscript-keyword">for</span> (CFIndex idx = CFArrayGetCount(array); idx--;) {
            CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);
            __CFRunLoopRemoveAllSources(rl, modeName);
        }
        __CFRunLoopRemoveAllSources(rl, kCFRunLoopCommonModes);
        CFRelease(array);
    }
    <span class="enscript-keyword">if</span> (rl) CFRelease(rl);
}

pthread_t <span class="enscript-function-name">_CFRunLoopGet1</span>(CFRunLoopRef rl) {
    <span class="enscript-keyword">return</span> rl-&gt;_pthread;
}

<span class="enscript-comment">// should only be called by Foundation
</span>CF_EXPORT CFTypeRef <span class="enscript-function-name">_CFRunLoopGet2</span>(CFRunLoopRef rl) {
    CFTypeRef ret = NULL;
    __CFSpinLock(&amp;loopsLock);
    ret = rl-&gt;_counterpart;
    __CFSpinUnlock(&amp;loopsLock);
    <span class="enscript-keyword">return</span> ret;
}

<span class="enscript-comment">// should only be called by Foundation
</span>CF_EXPORT CFTypeRef <span class="enscript-function-name">_CFRunLoopGet2b</span>(CFRunLoopRef rl) {
    <span class="enscript-keyword">return</span> rl-&gt;_counterpart;
}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span>
<span class="enscript-type">void</span> <span class="enscript-function-name">_CFRunLoopSetCurrent</span>(CFRunLoopRef rl) {
    <span class="enscript-keyword">if</span> (pthread_main_np()) <span class="enscript-keyword">return</span>;
    CFRunLoopRef currentLoop = CFRunLoopGetCurrent();
    <span class="enscript-keyword">if</span> (rl != currentLoop) {
        CFRetain(currentLoop); <span class="enscript-comment">// avoid a deallocation of the currentLoop inside the lock
</span>        __CFSpinLock(&amp;loopsLock);
	<span class="enscript-keyword">if</span> (rl) {
	    CFDictionarySetValue(__CFRunLoops, pthreadPointer(pthread_self()), rl);
	} <span class="enscript-keyword">else</span> {
	    CFDictionaryRemoveValue(__CFRunLoops, pthreadPointer(pthread_self()));
	}
        __CFSpinUnlock(&amp;loopsLock);
	CFRelease(currentLoop);
        _CFSetTSD(__CFTSDKeyRunLoop, NULL, NULL);
        _CFSetTSD(__CFTSDKeyRunLoopCntr, 0, (<span class="enscript-type">void</span> (*)(<span class="enscript-type">void</span> *))__CFFinalizeRunLoop);
    }
}
#<span class="enscript-reference">endif</span>

CFRunLoopRef <span class="enscript-function-name">CFRunLoopGetMain</span>(<span class="enscript-type">void</span>) {
    CHECK_FOR_FORK();
    <span class="enscript-type">static</span> CFRunLoopRef __main = NULL; <span class="enscript-comment">// no retain needed
</span>    <span class="enscript-keyword">if</span> (!__main) __main = _CFRunLoopGet0(_CFMainPThread); <span class="enscript-comment">// no CAS needed
</span>    <span class="enscript-keyword">return</span> __main;
}

CFRunLoopRef <span class="enscript-function-name">CFRunLoopGetCurrent</span>(<span class="enscript-type">void</span>) {
    CHECK_FOR_FORK();
    CFRunLoopRef rl = (CFRunLoopRef)_CFGetTSD(__CFTSDKeyRunLoop);
    <span class="enscript-keyword">if</span> (rl) <span class="enscript-keyword">return</span> rl;
    <span class="enscript-keyword">return</span> _CFRunLoopGet0(pthread_self());
}

CFStringRef <span class="enscript-function-name">CFRunLoopCopyCurrentMode</span>(CFRunLoopRef rl) {
    CHECK_FOR_FORK();
    CFStringRef result = NULL;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (NULL != rl-&gt;_currentMode) {
	result = (CFStringRef)CFRetain(rl-&gt;_currentMode-&gt;_name);
    }
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopGetModeName</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *context) {
    CFRunLoopModeRef rlm = (CFRunLoopModeRef)value;
    CFMutableArrayRef array = (CFMutableArrayRef)context;
    CFArrayAppendValue(array, rlm-&gt;_name);
}

CFArrayRef <span class="enscript-function-name">CFRunLoopCopyAllModes</span>(CFRunLoopRef rl) {
    CHECK_FOR_FORK();
    CFMutableArrayRef array;
    __CFRunLoopLock(rl);
    array = CFArrayCreateMutable(kCFAllocatorSystemDefault, CFSetGetCount(rl-&gt;_modes), &amp;kCFTypeArrayCallBacks);
    CFSetApplyFunction(rl-&gt;_modes, (__CFRunLoopGetModeName), array);
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> array;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopAddItemsToCommonMode</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *ctx) {
    CFTypeRef item = (CFTypeRef)value;
    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);
    CFStringRef modeName = (CFStringRef)(((CFTypeRef *)ctx)[1]);
    <span class="enscript-keyword">if</span> (CFGetTypeID(item) == __kCFRunLoopSourceTypeID) {
	CFRunLoopAddSource(rl, (CFRunLoopSourceRef)item, modeName);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CFGetTypeID(item) == __kCFRunLoopObserverTypeID) {
	CFRunLoopAddObserver(rl, (CFRunLoopObserverRef)item, modeName);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CFGetTypeID(item) == __kCFRunLoopTimerTypeID) {
	CFRunLoopAddTimer(rl, (CFRunLoopTimerRef)item, modeName);
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopAddItemToCommonModes</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *ctx) {
    CFStringRef modeName = (CFStringRef)value;
    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);
    CFTypeRef item = (CFTypeRef)(((CFTypeRef *)ctx)[1]);
    <span class="enscript-keyword">if</span> (CFGetTypeID(item) == __kCFRunLoopSourceTypeID) {
	CFRunLoopAddSource(rl, (CFRunLoopSourceRef)item, modeName);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CFGetTypeID(item) == __kCFRunLoopObserverTypeID) {
	CFRunLoopAddObserver(rl, (CFRunLoopObserverRef)item, modeName);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CFGetTypeID(item) == __kCFRunLoopTimerTypeID) {
	CFRunLoopAddTimer(rl, (CFRunLoopTimerRef)item, modeName);
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopRemoveItemFromCommonModes</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *ctx) {
    CFStringRef modeName = (CFStringRef)value;
    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);
    CFTypeRef item = (CFTypeRef)(((CFTypeRef *)ctx)[1]);
    <span class="enscript-keyword">if</span> (CFGetTypeID(item) == __kCFRunLoopSourceTypeID) {
	CFRunLoopRemoveSource(rl, (CFRunLoopSourceRef)item, modeName);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CFGetTypeID(item) == __kCFRunLoopObserverTypeID) {
	CFRunLoopRemoveObserver(rl, (CFRunLoopObserverRef)item, modeName);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CFGetTypeID(item) == __kCFRunLoopTimerTypeID) {
	CFRunLoopRemoveTimer(rl, (CFRunLoopTimerRef)item, modeName);
    }
}

CF_EXPORT Boolean <span class="enscript-function-name">_CFRunLoop01</span>(CFRunLoopRef rl, CFStringRef modeName) {
    __CFRunLoopLock(rl);
    Boolean present = CFSetContainsValue(rl-&gt;_commonModes, modeName);
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> present; 
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopAddCommonMode</span>(CFRunLoopRef rl, CFStringRef modeName) {
    CHECK_FOR_FORK();
    <span class="enscript-keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="enscript-keyword">return</span>;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (!CFSetContainsValue(rl-&gt;_commonModes, modeName)) {
	CFSetRef set = rl-&gt;_commonModeItems ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModeItems) : NULL;
	CFSetAddValue(rl-&gt;_commonModes, modeName);
	<span class="enscript-keyword">if</span> (NULL != set) {
	    CFTypeRef context[2] = {rl, modeName};
	    <span class="enscript-comment">/* add all common-modes items to new mode */</span>
	    CFSetApplyFunction(set, (__CFRunLoopAddItemsToCommonMode), (<span class="enscript-type">void</span> *)context);
	    CFRelease(set);
	}
    } <span class="enscript-keyword">else</span> {
    }
    __CFRunLoopUnlock(rl);
}


<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>() __attribute__((noinline));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__</span>(CFRunLoopObserverCallBack func, CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="enscript-type">void</span> *info) {
    <span class="enscript-keyword">if</span> (func) {
        func(observer, activity, info);
    }
    getpid(); <span class="enscript-comment">// thwart tail-call optimization
</span>}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span>() __attribute__((noinline));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__</span>(CFRunLoopTimerCallBack func, CFRunLoopTimerRef timer, <span class="enscript-type">void</span> *info) {
    <span class="enscript-keyword">if</span> (func) {
        func(timer, info);
    }
    getpid(); <span class="enscript-comment">// thwart tail-call optimization
</span>}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>() __attribute__((noinline));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__</span>(<span class="enscript-type">void</span> (^block)(<span class="enscript-type">void</span>)) {
    <span class="enscript-keyword">if</span> (block) {
        block();
    }
    getpid(); <span class="enscript-comment">// thwart tail-call optimization
</span>}

<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopDoBlocks</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm) { <span class="enscript-comment">// Call with rl and rlm locked
</span>    <span class="enscript-keyword">if</span> (!rl-&gt;_blocks_head) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (!rlm || !rlm-&gt;_name) <span class="enscript-keyword">return</span> false;
    Boolean did = false;
    <span class="enscript-type">struct</span> _block_item *head = rl-&gt;_blocks_head;
    <span class="enscript-type">struct</span> _block_item *tail = rl-&gt;_blocks_tail;
    rl-&gt;_blocks_head = NULL;
    rl-&gt;_blocks_tail = NULL;
    CFSetRef commonModes = rl-&gt;_commonModes;
    CFStringRef curMode = rlm-&gt;_name;
    __CFRunLoopModeUnlock(rlm);
    __CFRunLoopUnlock(rl);
    <span class="enscript-type">struct</span> _block_item *prev = NULL;
    <span class="enscript-type">struct</span> _block_item *item = head;
    <span class="enscript-keyword">while</span> (item) {
        <span class="enscript-type">struct</span> _block_item *curr = item;
        item = item-&gt;_next;
	Boolean doit = false;
	<span class="enscript-keyword">if</span> (CFStringGetTypeID() == CFGetTypeID(curr-&gt;_mode)) {
	    doit = CFEqual(curr-&gt;_mode, curMode) || (CFEqual(curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));
        } <span class="enscript-keyword">else</span> {
	    doit = CFSetContainsValue((CFSetRef)curr-&gt;_mode, curMode) || (CFSetContainsValue((CFSetRef)curr-&gt;_mode, kCFRunLoopCommonModes) &amp;&amp; CFSetContainsValue(commonModes, curMode));
	}
	<span class="enscript-keyword">if</span> (!doit) prev = curr;
	<span class="enscript-keyword">if</span> (doit) {
	    <span class="enscript-keyword">if</span> (prev) prev-&gt;_next = item;
	    <span class="enscript-keyword">if</span> (curr == head) head = item;
	    <span class="enscript-keyword">if</span> (curr == tail) tail = prev;
	    <span class="enscript-type">void</span> (^block)(<span class="enscript-type">void</span>) = curr-&gt;_block;
            CFRelease(curr-&gt;_mode);
            free(curr);
	    <span class="enscript-keyword">if</span> (doit) {
                __CFRUNLOOP_IS_CALLING_OUT_TO_A_BLOCK__(block);
	        did = true;
	    }
            Block_release(block); <span class="enscript-comment">// do this before relocking to prevent deadlocks where some yahoo wants to run the run loop reentrantly from their dealloc
</span>	}
    }
    __CFRunLoopLock(rl);
    __CFRunLoopModeLock(rlm);
    <span class="enscript-keyword">if</span> (head) {
	tail-&gt;_next = rl-&gt;_blocks_head;
	rl-&gt;_blocks_head = head;
        <span class="enscript-keyword">if</span> (!rl-&gt;_blocks_tail) rl-&gt;_blocks_tail = tail;
    }
    <span class="enscript-keyword">return</span> did;
}

<span class="enscript-comment">/* rl is locked, rlm is locked on entrance and exit */</span>
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopDoObservers</span>() __attribute__((noinline));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopDoObservers</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopActivity activity) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();

    CFIndex cnt = rlm-&gt;_observers ? CFArrayGetCount(rlm-&gt;_observers) : 0;
    <span class="enscript-keyword">if</span> (cnt &lt; 1) <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">/* Fire the observers */</span>
    STACK_BUFFER_DECL(CFRunLoopObserverRef, buffer, (cnt &lt;= 1024) ? cnt : 1);
    CFRunLoopObserverRef *collectedObservers = (cnt &lt;= 1024) ? buffer : (CFRunLoopObserverRef *)malloc(cnt * <span class="enscript-keyword">sizeof</span>(CFRunLoopObserverRef));
    CFIndex obs_cnt = 0;
    <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
        CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);
        <span class="enscript-keyword">if</span> (0 != (rlo-&gt;_activities &amp; activity) &amp;&amp; __CFIsValid(rlo) &amp;&amp; !__CFRunLoopObserverIsFiring(rlo)) {
            collectedObservers[obs_cnt++] = (CFRunLoopObserverRef)CFRetain(rlo);
        }
    }
    __CFRunLoopModeUnlock(rlm);
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; obs_cnt; idx++) {
        CFRunLoopObserverRef rlo = collectedObservers[idx];
        __CFRunLoopObserverLock(rlo);
        <span class="enscript-keyword">if</span> (__CFIsValid(rlo)) {
            Boolean doInvalidate = !__CFRunLoopObserverRepeats(rlo);
            __CFRunLoopObserverSetFiring(rlo);
            __CFRunLoopObserverUnlock(rlo);
            __CFRUNLOOP_IS_CALLING_OUT_TO_AN_OBSERVER_CALLBACK_FUNCTION__(rlo-&gt;_callout, rlo, activity, rlo-&gt;_context.info);
            <span class="enscript-keyword">if</span> (doInvalidate) {
                CFRunLoopObserverInvalidate(rlo);
            }
            __CFRunLoopObserverUnsetFiring(rlo);
        } <span class="enscript-keyword">else</span> {
            __CFRunLoopObserverUnlock(rlo);
        }
        CFRelease(rlo);
    }
    __CFRunLoopLock(rl);
    __CFRunLoopModeLock(rlm);

    <span class="enscript-keyword">if</span> (collectedObservers != buffer) free(collectedObservers);
}

<span class="enscript-type">static</span> CFComparisonResult <span class="enscript-function-name">__CFRunLoopSourceComparator</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *val1, <span class="enscript-type">const</span> <span class="enscript-type">void</span> *val2, <span class="enscript-type">void</span> *context) {
    CFRunLoopSourceRef o1 = (CFRunLoopSourceRef)val1;
    CFRunLoopSourceRef o2 = (CFRunLoopSourceRef)val2;
    <span class="enscript-keyword">if</span> (o1-&gt;_order &lt; o2-&gt;_order) <span class="enscript-keyword">return</span> kCFCompareLessThan;
    <span class="enscript-keyword">if</span> (o2-&gt;_order &lt; o1-&gt;_order) <span class="enscript-keyword">return</span> kCFCompareGreaterThan;
    <span class="enscript-keyword">return</span> kCFCompareEqualTo;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopCollectSources0</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *context) {
    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)value;
    CFTypeRef *sources = (CFTypeRef *)context;
    <span class="enscript-keyword">if</span> (0 == rls-&gt;_context.version0.version &amp;&amp; __CFIsValid(rls) &amp;&amp; __CFRunLoopSourceIsSignaled(rls)) {
	<span class="enscript-keyword">if</span> (NULL == *sources) {
	    *sources = CFRetain(rls);
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CFGetTypeID(*sources) == __kCFRunLoopSourceTypeID) {
	    CFTypeRef oldrls = *sources;
	    *sources = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);
	    CFArrayAppendValue((CFMutableArrayRef)*sources, oldrls);
	    CFArrayAppendValue((CFMutableArrayRef)*sources, rls);
	    CFRelease(oldrls);
	} <span class="enscript-keyword">else</span> {
	    CFArrayAppendValue((CFMutableArrayRef)*sources, rls);
	}
    }
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span>() __attribute__((noinline));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__</span>(<span class="enscript-type">void</span> (*perform)(<span class="enscript-type">void</span> *), <span class="enscript-type">void</span> *info) {
    <span class="enscript-keyword">if</span> (perform) {
        perform(info);
    }
    getpid(); <span class="enscript-comment">// thwart tail-call optimization
</span>}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span>() __attribute__((noinline));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__</span>(
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
        <span class="enscript-type">void</span> *(*perform)(<span class="enscript-type">void</span> *msg, CFIndex size, CFAllocatorRef allocator, <span class="enscript-type">void</span> *info),
        mach_msg_header_t *msg, CFIndex size, mach_msg_header_t **reply,
#<span class="enscript-reference">else</span>
        <span class="enscript-type">void</span> (*perform)(<span class="enscript-type">void</span> *),
#<span class="enscript-reference">endif</span>
        <span class="enscript-type">void</span> *info) {
    <span class="enscript-keyword">if</span> (perform) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
        *reply = perform(msg, size, kCFAllocatorSystemDefault, info);
#<span class="enscript-reference">else</span>
        perform(info);
#<span class="enscript-reference">endif</span>
    }
    getpid(); <span class="enscript-comment">// thwart tail-call optimization
</span>}

<span class="enscript-comment">/* rl is locked, rlm is locked on entrance and exit */</span>
<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopDoSources0</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) __attribute__((noinline));
<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopDoSources0</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, Boolean stopAfterHandle) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();
    CFTypeRef sources = NULL;
    Boolean sourceHandled = false;

    <span class="enscript-comment">/* Fire the version 0 sources */</span>
    <span class="enscript-keyword">if</span> (NULL != rlm-&gt;_sources0 &amp;&amp; 0 &lt; CFSetGetCount(rlm-&gt;_sources0)) {
	CFSetApplyFunction(rlm-&gt;_sources0, (__CFRunLoopCollectSources0), &amp;sources);
    }
    <span class="enscript-keyword">if</span> (NULL != sources) {
	__CFRunLoopModeUnlock(rlm);
	__CFRunLoopUnlock(rl);
	<span class="enscript-comment">// sources is either a single (retained) CFRunLoopSourceRef or an array of (retained) CFRunLoopSourceRef
</span>	<span class="enscript-keyword">if</span> (CFGetTypeID(sources) == __kCFRunLoopSourceTypeID) {
	    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)sources;
	    __CFRunLoopSourceLock(rls);
            <span class="enscript-keyword">if</span> (__CFRunLoopSourceIsSignaled(rls)) {
	        __CFRunLoopSourceUnsetSignaled(rls);
	        <span class="enscript-keyword">if</span> (__CFIsValid(rls)) {
	            __CFRunLoopSourceUnlock(rls);
                    __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);
	            CHECK_FOR_FORK();
	            sourceHandled = true;
	        } <span class="enscript-keyword">else</span> {
	            __CFRunLoopSourceUnlock(rls);
	        }
            } <span class="enscript-keyword">else</span> {
                __CFRunLoopSourceUnlock(rls);
            }
	} <span class="enscript-keyword">else</span> {
	    CFIndex cnt = CFArrayGetCount((CFArrayRef)sources);
	    CFArraySortValues((CFMutableArrayRef)sources, CFRangeMake(0, cnt), (__CFRunLoopSourceComparator), NULL);
	    <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
		CFRunLoopSourceRef rls = (CFRunLoopSourceRef)CFArrayGetValueAtIndex((CFArrayRef)sources, idx);
		__CFRunLoopSourceLock(rls);
                <span class="enscript-keyword">if</span> (__CFRunLoopSourceIsSignaled(rls)) {
		    __CFRunLoopSourceUnsetSignaled(rls);
		    <span class="enscript-keyword">if</span> (__CFIsValid(rls)) {
		        __CFRunLoopSourceUnlock(rls);
                        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE0_PERFORM_FUNCTION__(rls-&gt;_context.version0.perform, rls-&gt;_context.version0.info);
		        CHECK_FOR_FORK();
		        sourceHandled = true;
		    } <span class="enscript-keyword">else</span> {
		        __CFRunLoopSourceUnlock(rls);
		    }
                } <span class="enscript-keyword">else</span> {
                    __CFRunLoopSourceUnlock(rls);
                }
		<span class="enscript-keyword">if</span> (stopAfterHandle &amp;&amp; sourceHandled) {
		    <span class="enscript-keyword">break</span>;
		}
	    }
	}
	CFRelease(sources);
	__CFRunLoopLock(rl);
	__CFRunLoopModeLock(rlm);
    }
    <span class="enscript-keyword">return</span> sourceHandled;
}

<span class="enscript-comment">// msg, size and reply are unused on Windows
</span><span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopDoSource1</span>() __attribute__((noinline));
<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopDoSource1</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopSourceRef rls
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
                                    , mach_msg_header_t *msg, CFIndex size, mach_msg_header_t **reply
#<span class="enscript-reference">endif</span>
                                    ) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();
    Boolean sourceHandled = false;

    <span class="enscript-comment">/* Fire a version 1 source */</span>
    CFRetain(rls);
    __CFRunLoopModeUnlock(rlm);
    __CFRunLoopUnlock(rl);
    __CFRunLoopSourceLock(rls);
    <span class="enscript-keyword">if</span> (__CFIsValid(rls)) {
	__CFRunLoopSourceUnsetSignaled(rls);
	__CFRunLoopSourceUnlock(rls);
        __CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__(rls-&gt;_context.version1.perform,
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
            msg, size, reply,
#<span class="enscript-reference">endif</span>
            rls-&gt;_context.version1.info);
	CHECK_FOR_FORK();
	sourceHandled = true;
    } <span class="enscript-keyword">else</span> {
        <span class="enscript-keyword">if</span> (_LogCFRunLoop) { CFLog(kCFLogLevelDebug, CFSTR(<span class="enscript-string">"%p (%s) __CFRunLoopDoSource1 rls %p is invalid"</span>), CFRunLoopGetCurrent(), *_CFGetProgname(), rls); }
	__CFRunLoopSourceUnlock(rls);
    }
    CFRelease(rls);
    __CFRunLoopLock(rl);
    __CFRunLoopModeLock(rlm);
    <span class="enscript-keyword">return</span> sourceHandled;
}

<span class="enscript-type">static</span> CFIndex <span class="enscript-function-name">__CFRunLoopInsertionIndexInTimerArray</span>(CFArrayRef array, CFRunLoopTimerRef rlt) __attribute__((noinline));
<span class="enscript-type">static</span> CFIndex <span class="enscript-function-name">__CFRunLoopInsertionIndexInTimerArray</span>(CFArrayRef array, CFRunLoopTimerRef rlt) {
    CFIndex cnt = CFArrayGetCount(array);
    <span class="enscript-keyword">if</span> (cnt &lt;= 0) {
        <span class="enscript-keyword">return</span> 0;
    }
    <span class="enscript-keyword">if</span> (256 &lt; cnt) {
        CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, cnt - 1);
        <span class="enscript-keyword">if</span> (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) {
            <span class="enscript-keyword">return</span> cnt;
        }
        item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, 0);
        <span class="enscript-keyword">if</span> (rlt-&gt;_fireTSR &lt; item-&gt;_fireTSR) {
            <span class="enscript-keyword">return</span> 0;
        }
    }

    CFIndex add = (1 &lt;&lt; flsl(cnt)) * 2;
    CFIndex idx = 0;
    Boolean lastTestLEQ;
    <span class="enscript-keyword">do</span> {
        add = add / 2;
	lastTestLEQ = false;
        CFIndex testIdx = idx + add;
        <span class="enscript-keyword">if</span> (testIdx &lt; cnt) {
            CFRunLoopTimerRef item = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(array, testIdx);
            <span class="enscript-keyword">if</span> (item-&gt;_fireTSR &lt;= rlt-&gt;_fireTSR) {
                idx = testIdx;
		lastTestLEQ = true;
            }
        }
    } <span class="enscript-keyword">while</span> (0 &lt; add);

    <span class="enscript-keyword">return</span> lastTestLEQ ? idx + 1 : idx;
}

<span class="enscript-comment">// call with rlm and its run loop locked, and the TSRLock locked; rlt not locked; returns with same state
</span><span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRepositionTimerInMode</span>(CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt, Boolean isInArray) __attribute__((noinline));
<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRepositionTimerInMode</span>(CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt, Boolean isInArray) {
    <span class="enscript-keyword">if</span> (!rlt || !rlm-&gt;_timers) <span class="enscript-keyword">return</span>;
    Boolean found = false;
    <span class="enscript-keyword">if</span> (isInArray) {
	CFIndex idx = CFArrayGetFirstIndexOfValue(rlm-&gt;_timers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_timers)), rlt);
	<span class="enscript-keyword">if</span> (kCFNotFound != idx) {
	    CFRetain(rlt);
	    CFArrayRemoveValueAtIndex(rlm-&gt;_timers, idx);
	    found = true;
	}
    }
    <span class="enscript-keyword">if</span> (!found &amp;&amp; isInArray) <span class="enscript-keyword">return</span>;
    CFIndex newIdx = __CFRunLoopInsertionIndexInTimerArray(rlm-&gt;_timers, rlt);
    CFArrayInsertValueAtIndex(rlm-&gt;_timers, newIdx, rlt);
    CFRunLoopTimerRef nextTimer = NULL;
    <span class="enscript-keyword">for</span> (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) {
        CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);
        <span class="enscript-keyword">if</span> (!__CFRunLoopTimerIsFiring(t)) {
            nextTimer = t;
            <span class="enscript-keyword">break</span>;
        }
    }
    <span class="enscript-keyword">if</span> (nextTimer) {
        int64_t fireTSR = nextTimer-&gt;_fireTSR;
        fireTSR = (fireTSR / tenus + 1) * tenus;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
        mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(fireTSR));
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
        LARGE_INTEGER dueTime;
        dueTime.QuadPart = __CFTSRToFiletime(fireTSR);
        SetWaitableTimer(rlm-&gt;_timerPort, &amp;dueTime, 0, NULL, NULL, FALSE);
#<span class="enscript-reference">endif</span>
    }
    <span class="enscript-keyword">if</span> (isInArray) CFRelease(rlt);
}

<span class="enscript-comment">// mode and rl are locked on entry and exit
</span><span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopDoTimer</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFRunLoopTimerRef rlt) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    Boolean timerHandled = false;
    int64_t oldFireTSR = 0;

    <span class="enscript-comment">/* Fire a timer */</span>
    CFRetain(rlt);
    __CFRunLoopTimerLock(rlt);

    <span class="enscript-keyword">if</span> (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= (int64_t)mach_absolute_time() &amp;&amp; !__CFRunLoopTimerIsFiring(rlt) &amp;&amp; rlt-&gt;_runLoop == rl) {
        <span class="enscript-type">void</span> *context_info = NULL;
        <span class="enscript-type">void</span> (*context_release)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *) = NULL;
        <span class="enscript-keyword">if</span> (rlt-&gt;_context.retain) {
            context_info = (<span class="enscript-type">void</span> *)rlt-&gt;_context.retain(rlt-&gt;_context.info);
            context_release = rlt-&gt;_context.release;
        } <span class="enscript-keyword">else</span> {
            context_info = rlt-&gt;_context.info;
        }
        Boolean doInvalidate = (0.0 == rlt-&gt;_interval);
	__CFRunLoopTimerSetFiring(rlt);
        __CFRunLoopTimerUnlock(rlt);
	__CFRunLoopTimerFireTSRLock();
	oldFireTSR = rlt-&gt;_fireTSR;
	__CFRunLoopTimerFireTSRUnlock();

        CFRunLoopTimerRef nextTimer = NULL;
        <span class="enscript-keyword">for</span> (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) {
            CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);
            <span class="enscript-keyword">if</span> (!__CFRunLoopTimerIsFiring(t)) {
                nextTimer = t;
                <span class="enscript-keyword">break</span>;
            }
        }
        <span class="enscript-keyword">if</span> (nextTimer) {
            int64_t fireTSR = nextTimer-&gt;_fireTSR;
            fireTSR = (fireTSR / tenus + 1) * tenus;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
            mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(fireTSR));
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
            LARGE_INTEGER dueTime;
            dueTime.QuadPart = __CFTSRToFiletime(fireTSR);
            SetWaitableTimer(rlm-&gt;_timerPort, &amp;dueTime, 0, NULL, NULL, FALSE);
#<span class="enscript-reference">endif</span>
        }

	__CFRunLoopModeUnlock(rlm);
	__CFRunLoopUnlock(rl);
	__CFRUNLOOP_IS_CALLING_OUT_TO_A_TIMER_CALLBACK_FUNCTION__(rlt-&gt;_callout, rlt, context_info);
	CHECK_FOR_FORK();
        <span class="enscript-keyword">if</span> (doInvalidate) {
            CFRunLoopTimerInvalidate(rlt);      <span class="enscript-comment">/* DOES CALLOUT */</span>
        }
        <span class="enscript-keyword">if</span> (context_release) {
            context_release(context_info);
        }
	__CFRunLoopLock(rl);
	__CFRunLoopModeLock(rlm);
        __CFRunLoopTimerLock(rlt);
	timerHandled = true;
	__CFRunLoopTimerUnsetFiring(rlt);
    }
    <span class="enscript-keyword">if</span> (__CFIsValid(rlt) &amp;&amp; timerHandled) {
        <span class="enscript-comment">/* This is just a little bit tricky: we want to support calling
         * CFRunLoopTimerSetNextFireDate() from within the callout and
         * honor that new time here if it is a later date, otherwise
         * it is completely ignored. */</span>
        <span class="enscript-keyword">if</span> (oldFireTSR &lt; rlt-&gt;_fireTSR) {
            <span class="enscript-comment">/* Next fire TSR was set, and set to a date after the previous
            * fire date, so we honor it. */</span>
            __CFRunLoopTimerUnlock(rlt);
            <span class="enscript-comment">// The timer was adjusted and repositioned, during the
</span>            <span class="enscript-comment">// callout, but if it was still the min timer, it was
</span>            <span class="enscript-comment">// skipped because it was firing.  Need to redo the
</span>            <span class="enscript-comment">// min timer calculation in case rlt should now be that
</span>            <span class="enscript-comment">// timer instead of whatever was chosen.
</span>            CFRunLoopTimerRef nextTimer = NULL;
            <span class="enscript-keyword">for</span> (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) {
                CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);
                <span class="enscript-keyword">if</span> (!__CFRunLoopTimerIsFiring(t)) {
                    nextTimer = t;
                    <span class="enscript-keyword">break</span>;
                }
            }
            <span class="enscript-keyword">if</span> (nextTimer) {
                int64_t fireTSR = nextTimer-&gt;_fireTSR;
                fireTSR = (fireTSR / tenus + 1) * tenus;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
                mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(fireTSR));
#<span class="enscript-reference">else</span>
                LARGE_INTEGER dueTime;
                dueTime.QuadPart = __CFTSRToFiletime(fireTSR);
                SetWaitableTimer(rlm-&gt;_timerPort, &amp;dueTime, 0, NULL, NULL, FALSE);
#<span class="enscript-reference">endif</span>
            }
        } <span class="enscript-keyword">else</span> {
	    int64_t nextFireTSR = 0LL;
            int64_t intervalTSR = 0LL;
            <span class="enscript-keyword">if</span> (rlt-&gt;_interval &lt;= 0.0) {
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (TIMER_INTERVAL_LIMIT &lt; rlt-&gt;_interval) {
        	intervalTSR = __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);
            } <span class="enscript-keyword">else</span> {
        	intervalTSR = __CFTimeIntervalToTSR(rlt-&gt;_interval);
            }
            <span class="enscript-keyword">if</span> (LLONG_MAX - intervalTSR &lt;= oldFireTSR) {
                nextFireTSR = LLONG_MAX;
            } <span class="enscript-keyword">else</span> {
                int64_t currentTSR = (int64_t)mach_absolute_time();
                nextFireTSR = oldFireTSR;
                <span class="enscript-keyword">while</span> (nextFireTSR &lt;= currentTSR) {
                    nextFireTSR += intervalTSR;
                }
            }
            CFRunLoopRef rlt_rl = rlt-&gt;_runLoop;
            <span class="enscript-keyword">if</span> (rlt_rl) {
                CFRetain(rlt_rl);
		CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes);
		STACK_BUFFER_DECL(CFTypeRef, modes, cnt);
		CFSetGetValues(rlt-&gt;_rlModes, (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **)modes);
		<span class="enscript-comment">// To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up
</span>		<span class="enscript-comment">// towards the run loop from a source, the timer has to be
</span>		<span class="enscript-comment">// unlocked, which means we have to protect from object
</span>		<span class="enscript-comment">// invalidation, although that's somewhat expensive.
</span>		<span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
		    CFRetain(modes[idx]);
		}
		__CFRunLoopTimerUnlock(rlt);
		<span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
		    CFStringRef name = (CFStringRef)modes[idx];
		    modes[idx] = (CFTypeRef)__CFRunLoopFindMode(rlt_rl, name, false);
		    CFRelease(name);
		}
		__CFRunLoopTimerFireTSRLock();
		rlt-&gt;_fireTSR = nextFireTSR;
                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTSRToTimeInterval(nextFireTSR - (int64_t)mach_absolute_time());
		<span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
		    CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx];
		    <span class="enscript-keyword">if</span> (rlm) {
			__CFRepositionTimerInMode(rlm, rlt, true);
		    }
		}
		__CFRunLoopTimerFireTSRUnlock();
		<span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
		    __CFRunLoopModeUnlock((CFRunLoopModeRef)modes[idx]);
		}
		CFRelease(rlt_rl);
	    } <span class="enscript-keyword">else</span> {
		__CFRunLoopTimerUnlock(rlt);
		__CFRunLoopTimerFireTSRLock();
		rlt-&gt;_fireTSR = nextFireTSR;
                rlt-&gt;_nextFireDate = CFAbsoluteTimeGetCurrent() + __CFTSRToTimeInterval(nextFireTSR - (int64_t)mach_absolute_time());
		__CFRunLoopTimerFireTSRUnlock();
            }
        }
    } <span class="enscript-keyword">else</span> {
        __CFRunLoopTimerUnlock(rlt);
    }
    CFRelease(rlt);
    <span class="enscript-keyword">return</span> timerHandled;
}

<span class="enscript-comment">// rl and rlm are locked on entry and exit
</span><span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopDoTimers</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, int64_t limitTSR) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    Boolean timerHandled = false;
    CFMutableArrayRef timers = NULL;
    <span class="enscript-keyword">for</span> (CFIndex idx = 0, cnt = rlm-&gt;_timers ? CFArrayGetCount(rlm-&gt;_timers) : 0; idx &lt; cnt; idx++) {
        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);
        <span class="enscript-keyword">if</span> (__CFIsValid(rlt) &amp;&amp; rlt-&gt;_fireTSR &lt;= limitTSR &amp;&amp; !__CFRunLoopTimerIsFiring(rlt)) {
            <span class="enscript-keyword">if</span> (!timers) timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);
            CFArrayAppendValue(timers, rlt);
        }
    }
    <span class="enscript-keyword">for</span> (CFIndex idx = 0, cnt = timers ? CFArrayGetCount(timers) : 0; idx &lt; cnt; idx++) {
        CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(timers, idx);
        Boolean did = __CFRunLoopDoTimer(rl, rlm, rlt);
        timerHandled = timerHandled || did;
    }
    <span class="enscript-keyword">if</span> (timers) CFRelease(timers);
    <span class="enscript-keyword">return</span> timerHandled;
}


CF_EXPORT Boolean <span class="enscript-function-name">_CFRunLoopFinished</span>(CFRunLoopRef rl, CFStringRef modeName) {
    CHECK_FOR_FORK();
    CFRunLoopModeRef rlm;
    Boolean result = false;
    __CFRunLoopLock(rl);
    rlm = __CFRunLoopFindMode(rl, modeName, false);
    <span class="enscript-keyword">if</span> (NULL == rlm || __CFRunLoopModeIsEmpty(rl, rlm, NULL)) {
	result = true;
    }
    <span class="enscript-keyword">if</span> (rlm) __CFRunLoopModeUnlock(rlm);
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> int32_t <span class="enscript-function-name">__CFRunLoopRun</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) __attribute__((noinline));

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TIMEOUT_INFINITY</span> (~(mach_msg_timeout_t)0)

<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopServiceMachPort</span>(mach_port_name_t port, mach_msg_header_t **buffer, size_t buffer_size, mach_msg_timeout_t timeout) {
    Boolean originalBuffer = true;
    <span class="enscript-keyword">for</span> (;;) {		<span class="enscript-comment">/* In that sleep of death what nightmares may come ... */</span>
        mach_msg_header_t *msg = (mach_msg_header_t *)*buffer;
        msg-&gt;msgh_bits = 0;
        msg-&gt;msgh_local_port = port;
        msg-&gt;msgh_remote_port = MACH_PORT_NULL;
        msg-&gt;msgh_size = buffer_size;
        msg-&gt;msgh_id = 0;
        kern_return_t ret = mach_msg(msg, MACH_RCV_MSG|MACH_RCV_LARGE|((TIMEOUT_INFINITY != timeout) ? MACH_RCV_TIMEOUT : 0)|MACH_RCV_TRAILER_TYPE(MACH_MSG_TRAILER_FORMAT_0)|MACH_RCV_TRAILER_ELEMENTS(MACH_RCV_TRAILER_AV), 0, msg-&gt;msgh_size, port, timeout, MACH_PORT_NULL);
        <span class="enscript-keyword">if</span> (MACH_MSG_SUCCESS == ret) <span class="enscript-keyword">return</span> true;
        <span class="enscript-keyword">if</span> (MACH_RCV_TIMED_OUT == ret) {
            <span class="enscript-keyword">if</span> (!originalBuffer) free(msg);
            *buffer = NULL;
            <span class="enscript-keyword">return</span> false;
        }
        <span class="enscript-keyword">if</span> (MACH_RCV_TOO_LARGE != ret) <span class="enscript-keyword">break</span>;
        buffer_size = round_msg(msg-&gt;msgh_size + MAX_TRAILER_SIZE);
        <span class="enscript-keyword">if</span> (originalBuffer) *buffer = NULL;
        originalBuffer = false;
        *buffer = realloc(*buffer, buffer_size);
    }
    HALT;
    <span class="enscript-keyword">return</span> false;
}

#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>

#<span class="enscript-reference">define</span> <span class="enscript-variable-name">TIMEOUT_INFINITY</span> INFINITE

<span class="enscript-comment">// pass in either a portSet or onePort
</span><span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopWaitForMultipleObjects</span>(__CFPortSet portSet, HANDLE *onePort, DWORD timeout, DWORD mask, HANDLE *livePort, Boolean *msgReceived) {
    DWORD waitResult = WAIT_TIMEOUT;
    HANDLE handleBuf[MAXIMUM_WAIT_OBJECTS];
    HANDLE *handles = NULL;
    uint32_t handleCount = 0;
    Boolean freeHandles = false;
    Boolean result = false;
    
    <span class="enscript-keyword">if</span> (portSet) {
	<span class="enscript-comment">// copy out the handles to be safe from other threads at work
</span>	handles = __CFPortSetGetPorts(portSet, handleBuf, MAXIMUM_WAIT_OBJECTS, &amp;handleCount);
	freeHandles = (handles != handleBuf);
    } <span class="enscript-keyword">else</span> {
	handles = onePort;
	handleCount = 1;
	freeHandles = FALSE;
    }
    
    <span class="enscript-comment">// The run loop mode and loop are already in proper unlocked state from caller
</span>    waitResult = MsgWaitForMultipleObjectsEx(__CFMin(handleCount, MAXIMUM_WAIT_OBJECTS), handles, timeout, mask, MWMO_INPUTAVAILABLE);
    
    CFAssert2(waitResult != WAIT_FAILED, __kCFLogAssertion, <span class="enscript-string">"%s(): error %d from MsgWaitForMultipleObjects"</span>, __PRETTY_FUNCTION__, GetLastError());
    
    <span class="enscript-keyword">if</span> (waitResult == WAIT_TIMEOUT) {
	<span class="enscript-comment">// do nothing, just return to caller
</span>	result = false;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (waitResult &gt;= WAIT_OBJECT_0 &amp;&amp; waitResult &lt; WAIT_OBJECT_0+handleCount) {
	<span class="enscript-comment">// a handle was signaled
</span>	<span class="enscript-keyword">if</span> (livePort) *livePort = handles[waitResult-WAIT_OBJECT_0];
	result = true;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (waitResult == WAIT_OBJECT_0+handleCount) {
	<span class="enscript-comment">// windows message received
</span>        <span class="enscript-keyword">if</span> (msgReceived) *msgReceived = true;
	result = true;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (waitResult &gt;= WAIT_ABANDONED_0 &amp;&amp; waitResult &lt; WAIT_ABANDONED_0+handleCount) {
	<span class="enscript-comment">// an "abandoned mutex object"
</span>	<span class="enscript-keyword">if</span> (livePort) *livePort = handles[waitResult-WAIT_ABANDONED_0];
	result = true;
    } <span class="enscript-keyword">else</span> {
	CFAssert2(waitResult == WAIT_FAILED, __kCFLogAssertion, <span class="enscript-string">"%s(): unexpected result from MsgWaitForMultipleObjects: %d"</span>, __PRETTY_FUNCTION__, waitResult);
	result = false;
    }
    
    <span class="enscript-keyword">if</span> (freeHandles) {
	CFAllocatorDeallocate(kCFAllocatorSystemDefault, handles);
    }
    
    <span class="enscript-keyword">return</span> result;
}

#<span class="enscript-reference">endif</span>

<span class="enscript-type">struct</span> __timeout_context {
    dispatch_source_t ds;
    CFRunLoopRef rl;
    int64_t termTSR;
};

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimeoutCancel</span>(<span class="enscript-type">void</span> *arg) {
    <span class="enscript-type">struct</span> __timeout_context *context = (<span class="enscript-type">struct</span> __timeout_context *)arg;
    CFRelease(context-&gt;rl);
    dispatch_release(context-&gt;ds);
    free(context);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimeout</span>(<span class="enscript-type">void</span> *arg) {
    <span class="enscript-type">struct</span> __timeout_context *context = (<span class="enscript-type">struct</span> __timeout_context *)arg;
    context-&gt;termTSR = 0LL;
    CFRunLoopWakeUp(context-&gt;rl);
    <span class="enscript-comment">// The interval is DISPATCH_TIME_FOREVER, so this won't fire again
</span>}

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">MACH_PORT_NULL</span> 0
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">mach_port_name_t</span> HANDLE
#<span class="enscript-reference">define</span> <span class="enscript-variable-name">_dispatch_get_main_queue_port_4CF</span> _dispatch_get_main_queue_handle_4CF
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">deployment</span> <span class="enscript-variable-name">target</span> - <span class="enscript-variable-name">CFRunLoop</span> <span class="enscript-variable-name">not</span> <span class="enscript-variable-name">functional</span>
#<span class="enscript-reference">endif</span>

<span class="enscript-comment">/* rl, rlm are locked on entrance and exit */</span>
<span class="enscript-type">static</span> int32_t <span class="enscript-function-name">__CFRunLoopRun</span>(CFRunLoopRef rl, CFRunLoopModeRef rlm, CFTimeInterval seconds, Boolean stopAfterHandle, CFRunLoopModeRef previousMode) {
    int64_t startTSR = (int64_t)mach_absolute_time();

    <span class="enscript-keyword">if</span> (__CFRunLoopIsStopped(rl)) {
        __CFRunLoopUnsetStopped(rl);
	<span class="enscript-keyword">return</span> kCFRunLoopRunStopped;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rlm-&gt;_stopped) {
	rlm-&gt;_stopped = false;
	<span class="enscript-keyword">return</span> kCFRunLoopRunStopped;
    }

    mach_port_name_t dispatchPort = MACH_PORT_NULL;
    Boolean libdispatchQSafe = pthread_main_np() &amp;&amp; ((HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; NULL == previousMode) || (!HANDLE_DISPATCH_ON_BASE_INVOCATION_ONLY &amp;&amp; 0 == _CFGetTSD(__CFTSDKeyIsInGCDMainQ)));
    <span class="enscript-keyword">if</span> (libdispatchQSafe &amp;&amp; (CFRunLoopGetMain() == rl) &amp;&amp; CFSetContainsValue(rl-&gt;_commonModes, rlm-&gt;_name)) dispatchPort = _dispatch_get_main_queue_port_4CF();

    dispatch_source_t timeout_timer = NULL;
    <span class="enscript-type">struct</span> __timeout_context *timeout_context = (<span class="enscript-type">struct</span> __timeout_context *)malloc(<span class="enscript-keyword">sizeof</span>(*timeout_context));
    <span class="enscript-keyword">if</span> (seconds &lt;= 0.0) { <span class="enscript-comment">// instant timeout
</span>        seconds = 0.0;
        timeout_context-&gt;termTSR = 0LL;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (seconds &lt;= TIMER_INTERVAL_LIMIT) {
	dispatch_queue_t queue = dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, DISPATCH_QUEUE_OVERCOMMIT);
	timeout_timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);
        dispatch_retain(timeout_timer);
	timeout_context-&gt;ds = timeout_timer;
	timeout_context-&gt;rl = (CFRunLoopRef)CFRetain(rl);
	timeout_context-&gt;termTSR = startTSR + __CFTimeIntervalToTSR(seconds);
	dispatch_set_context(timeout_timer, timeout_context); <span class="enscript-comment">// source gets ownership of context
</span>	dispatch_source_set_event_handler_f(timeout_timer, __CFRunLoopTimeout);
        dispatch_source_set_cancel_handler_f(timeout_timer, __CFRunLoopTimeoutCancel);
        uint64_t nanos = (uint64_t)(seconds * 1000 * 1000 + 1) * 1000;
	dispatch_source_set_timer(timeout_timer, dispatch_time(DISPATCH_TIME_NOW, nanos), DISPATCH_TIME_FOREVER, 0);
	dispatch_resume(timeout_timer);
    } <span class="enscript-keyword">else</span> { <span class="enscript-comment">// infinite timeout
</span>        seconds = 9999999999.0;
        timeout_context-&gt;termTSR = INT64_MAX;
    }

    Boolean didDispatchPortLastTime = true;
    int32_t retVal = 0;
    <span class="enscript-keyword">do</span> {
        uint8_t msg_buffer[3 * 1024];
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
        mach_msg_header_t *msg = NULL;
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
        HANDLE livePort = NULL;
        Boolean windowsMessageReceived = false;
#<span class="enscript-reference">endif</span>
	__CFPortSet waitSet = rlm-&gt;_portSet;

	rl-&gt;_ignoreWakeUps = false;

        <span class="enscript-keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeTimers) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeTimers);
        <span class="enscript-keyword">if</span> (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeSources) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeSources);

	__CFRunLoopDoBlocks(rl, rlm);

        Boolean sourceHandledThisLoop = __CFRunLoopDoSources0(rl, rlm, stopAfterHandle);
        <span class="enscript-keyword">if</span> (sourceHandledThisLoop) {
            __CFRunLoopDoBlocks(rl, rlm);
	}

        Boolean poll = sourceHandledThisLoop || (0LL == timeout_context-&gt;termTSR);

        <span class="enscript-keyword">if</span> (MACH_PORT_NULL != dispatchPort &amp;&amp; !didDispatchPortLastTime) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
            msg = (mach_msg_header_t *)msg_buffer;
            <span class="enscript-keyword">if</span> (__CFRunLoopServiceMachPort(dispatchPort, &amp;msg, <span class="enscript-keyword">sizeof</span>(msg_buffer), 0)) {
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_msg</span>;
            }
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
            <span class="enscript-keyword">if</span> (__CFRunLoopWaitForMultipleObjects(NULL, &amp;dispatchPort, 0, 0, &amp;livePort, NULL)) {
                <span class="enscript-keyword">goto</span> <span class="enscript-reference">handle_msg</span>;
            }
#<span class="enscript-reference">endif</span>
        }

        didDispatchPortLastTime = false;

	<span class="enscript-keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopBeforeWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopBeforeWaiting);
	__CFRunLoopSetSleeping(rl);
	<span class="enscript-comment">// do not do any user callouts after this point (after notifying of sleeping)
</span>
        <span class="enscript-comment">// Must push the local-to-this-activation ports in on every loop
</span>        <span class="enscript-comment">// iteration, as this mode could be run re-entrantly and we don't
</span>        <span class="enscript-comment">// want these ports to get serviced.
</span>
        __CFPortSetInsert(dispatchPort, waitSet);

	__CFRunLoopModeUnlock(rlm);
	__CFRunLoopUnlock(rl);

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
        <span class="enscript-keyword">if</span> (kCFUseCollectableAllocator) {
            objc_clear_stack(0);
            memset(msg_buffer, 0, <span class="enscript-keyword">sizeof</span>(msg_buffer));
        }
        msg = (mach_msg_header_t *)msg_buffer;
        __CFRunLoopServiceMachPort(waitSet, &amp;msg, <span class="enscript-keyword">sizeof</span>(msg_buffer), poll ? 0 : TIMEOUT_INFINITY);
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
        <span class="enscript-comment">// Here, use the app-supplied message queue mask. They will set this if they are interested in having this run loop receive windows messages.
</span>        <span class="enscript-comment">// Note: don't pass 0 for polling, or this thread will never yield the CPU.
</span>        __CFRunLoopWaitForMultipleObjects(waitSet, NULL, poll ? 0 : TIMEOUT_INFINITY, rlm-&gt;_msgQMask, &amp;livePort, &amp;windowsMessageReceived);
#<span class="enscript-reference">endif</span>
        
        __CFRunLoopLock(rl);
        __CFRunLoopModeLock(rlm);

        <span class="enscript-comment">// Must remove the local-to-this-activation ports in on every loop
</span>        <span class="enscript-comment">// iteration, as this mode could be run re-entrantly and we don't
</span>        <span class="enscript-comment">// want these ports to get serviced. Also, we don't want them left
</span>        <span class="enscript-comment">// in there if this function returns.
</span>
        __CFPortSetRemove(dispatchPort, waitSet);

	rl-&gt;_ignoreWakeUps = true;

        <span class="enscript-comment">// user callouts now OK again
</span>	__CFRunLoopUnsetSleeping(rl);
	<span class="enscript-keyword">if</span> (!poll &amp;&amp; (rlm-&gt;_observerMask &amp; kCFRunLoopAfterWaiting)) __CFRunLoopDoObservers(rl, rlm, kCFRunLoopAfterWaiting);

        <span class="enscript-reference">handle_msg</span>:;
	rl-&gt;_ignoreWakeUps = true;

#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
        mach_port_t livePort = msg ? msg-&gt;msgh_local_port : MACH_PORT_NULL;
#<span class="enscript-reference">endif</span>
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
        <span class="enscript-keyword">if</span> (windowsMessageReceived) {
            <span class="enscript-comment">// These Win32 APIs cause a callout, so make sure we're unlocked first and relocked after
</span>            __CFRunLoopModeUnlock(rlm);
	    __CFRunLoopUnlock(rl);

            <span class="enscript-keyword">if</span> (rlm-&gt;_msgPump) {
                rlm-&gt;_msgPump();
            } <span class="enscript-keyword">else</span> {
                MSG msg;
                <span class="enscript-keyword">if</span> (PeekMessage(&amp;msg, NULL, 0, 0, PM_REMOVE | PM_NOYIELD)) {
                    TranslateMessage(&amp;msg);
                    DispatchMessage(&amp;msg);
                }
            }
            
            __CFRunLoopLock(rl);
	    __CFRunLoopModeLock(rlm);
 	    sourceHandledThisLoop = true;
        } <span class="enscript-keyword">else</span>
#<span class="enscript-reference">endif</span>
        <span class="enscript-keyword">if</span> (MACH_PORT_NULL == livePort) {
            <span class="enscript-comment">// handle nothing
</span>        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (livePort == rl-&gt;_wakeUpPort) {
            <span class="enscript-comment">// do nothing on Mac OS
</span>#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
            <span class="enscript-comment">// Always reset the wake up port, or risk spinning forever
</span>            ResetEvent(rl-&gt;_wakeUpPort);
#<span class="enscript-reference">endif</span>
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (livePort == rlm-&gt;_timerPort) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
            <span class="enscript-comment">// We use a manual reset timer to ensure that we don't miss timers firing because the run loop did the wakeUpPort this time
</span>            <span class="enscript-comment">// The only way to reset a timer is to reset the timer using SetWaitableTimer. We don't want it to fire again though, so we set the timeout to a large negative value. The timer may be reset again inside the timer handling code.
</span>            LARGE_INTEGER dueTime;
            dueTime.QuadPart = LONG_MIN;
            SetWaitableTimer(rlm-&gt;_timerPort, &amp;dueTime, 0, NULL, NULL, FALSE);
#<span class="enscript-reference">endif</span>
	    __CFRunLoopDoTimers(rl, rlm, mach_absolute_time());
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (livePort == dispatchPort) {
	    __CFRunLoopModeUnlock(rlm);
	    __CFRunLoopUnlock(rl);
            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="enscript-type">void</span> *)6, NULL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
 	    _dispatch_main_queue_callback_4CF(msg);
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
            _dispatch_main_queue_callback_4CF();
#<span class="enscript-reference">endif</span>
            _CFSetTSD(__CFTSDKeyIsInGCDMainQ, (<span class="enscript-type">void</span> *)0, NULL);
	    __CFRunLoopLock(rl);
	    __CFRunLoopModeLock(rlm);
 	    sourceHandledThisLoop = true;
            didDispatchPortLastTime = true;
        } <span class="enscript-keyword">else</span> {
            <span class="enscript-comment">// Despite the name, this works for windows handles as well
</span>            CFRunLoopSourceRef rls = __CFRunLoopModeFindSourceForMachPort(rl, rlm, livePort);
            <span class="enscript-keyword">if</span> (rls) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
		mach_msg_header_t *reply = NULL;
		sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls, msg, msg-&gt;msgh_size, &amp;reply) || sourceHandledThisLoop;
		<span class="enscript-keyword">if</span> (NULL != reply) {
		    (<span class="enscript-type">void</span>)mach_msg(reply, MACH_SEND_MSG, reply-&gt;msgh_size, 0, MACH_PORT_NULL, 0, MACH_PORT_NULL);
		    CFAllocatorDeallocate(kCFAllocatorSystemDefault, reply);
		}
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
                sourceHandledThisLoop = __CFRunLoopDoSource1(rl, rlm, rls) || sourceHandledThisLoop;
#<span class="enscript-reference">endif</span>
	    }
        } 
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
        <span class="enscript-keyword">if</span> (msg &amp;&amp; msg != (mach_msg_header_t *)msg_buffer) free(msg);
#<span class="enscript-reference">endif</span>
        
	__CFRunLoopDoBlocks(rl, rlm);

	<span class="enscript-keyword">if</span> (sourceHandledThisLoop &amp;&amp; stopAfterHandle) {
	    retVal = kCFRunLoopRunHandledSource;
        } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (timeout_context-&gt;termTSR &lt; (int64_t)mach_absolute_time()) {
            retVal = kCFRunLoopRunTimedOut;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (__CFRunLoopIsStopped(rl)) {
            __CFRunLoopUnsetStopped(rl);
	    retVal = kCFRunLoopRunStopped;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rlm-&gt;_stopped) {
	    rlm-&gt;_stopped = false;
	    retVal = kCFRunLoopRunStopped;
	} <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (__CFRunLoopModeIsEmpty(rl, rlm, previousMode)) {
	    retVal = kCFRunLoopRunFinished;
	}
    } <span class="enscript-keyword">while</span> (0 == retVal);

    <span class="enscript-keyword">if</span> (timeout_timer) {
        dispatch_source_cancel(timeout_timer);
        dispatch_release(timeout_timer);
    } <span class="enscript-keyword">else</span> {
        free(timeout_context);
    }

    <span class="enscript-keyword">return</span> retVal;
}

SInt32 <span class="enscript-function-name">CFRunLoopRunSpecific</span>(CFRunLoopRef rl, CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     <span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();
    <span class="enscript-keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="enscript-keyword">return</span> kCFRunLoopRunFinished;
    __CFRunLoopLock(rl);
    CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, modeName, false);
    <span class="enscript-keyword">if</span> (NULL == currentMode || __CFRunLoopModeIsEmpty(rl, currentMode, rl-&gt;_currentMode)) {
	Boolean did = false;
	<span class="enscript-keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);
	__CFRunLoopUnlock(rl);
	<span class="enscript-keyword">return</span> did ? kCFRunLoopRunHandledSource : kCFRunLoopRunFinished;
    }
    uint32_t *previousStopped = (uint32_t *)rl-&gt;_stopped;
    rl-&gt;_stopped = NULL;
    CFRunLoopModeRef previousMode = rl-&gt;_currentMode;
    rl-&gt;_currentMode = currentMode;
    int32_t result;
	<span class="enscript-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopEntry ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopEntry);
	result = __CFRunLoopRun(rl, currentMode, seconds, returnAfterSourceHandled, previousMode);
	<span class="enscript-keyword">if</span> (currentMode-&gt;_observerMask &amp; kCFRunLoopExit ) __CFRunLoopDoObservers(rl, currentMode, kCFRunLoopExit);
        __CFRunLoopModeUnlock(currentMode);
	<span class="enscript-keyword">if</span> (rl-&gt;_stopped) CFAllocatorDeallocate(kCFAllocatorSystemDefault, (uint32_t *)rl-&gt;_stopped);
	rl-&gt;_stopped = previousStopped;
	rl-&gt;_currentMode = previousMode;
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopRun</span>(<span class="enscript-type">void</span>) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    int32_t result;
    <span class="enscript-keyword">do</span> {
        result = CFRunLoopRunSpecific(CFRunLoopGetCurrent(), kCFRunLoopDefaultMode, 1.0e10, false);
        CHECK_FOR_FORK();
    } <span class="enscript-keyword">while</span> (kCFRunLoopRunStopped != result &amp;&amp; kCFRunLoopRunFinished != result);
}

SInt32 <span class="enscript-function-name">CFRunLoopRunInMode</span>(CFStringRef modeName, CFTimeInterval seconds, Boolean returnAfterSourceHandled) {     <span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();
    <span class="enscript-keyword">return</span> CFRunLoopRunSpecific(CFRunLoopGetCurrent(), modeName, seconds, returnAfterSourceHandled);
}

CFAbsoluteTime <span class="enscript-function-name">CFRunLoopGetNextTimerFireDate</span>(CFRunLoopRef rl, CFStringRef modeName) {
    CHECK_FOR_FORK();
    __CFRunLoopLock(rl);
    CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);
    CFAbsoluteTime at = 0.0;
    CFRunLoopTimerRef timer = (rlm &amp;&amp; rlm-&gt;_timers &amp;&amp; 0 &lt; CFArrayGetCount(rlm-&gt;_timers)) ? (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, 0) : NULL;
    <span class="enscript-keyword">if</span> (timer) at = CFRunLoopTimerGetNextFireDate(timer);
    <span class="enscript-keyword">if</span> (rlm) __CFRunLoopModeUnlock(rlm);
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> at;
}

Boolean <span class="enscript-function-name">CFRunLoopIsWaiting</span>(CFRunLoopRef rl) {
    CHECK_FOR_FORK();
    <span class="enscript-keyword">return</span> __CFRunLoopIsSleeping(rl);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopWakeUp</span>(CFRunLoopRef rl) {
    CHECK_FOR_FORK();
    <span class="enscript-comment">// This lock is crucial to ignorable wakeups, do not remove it.
</span>    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (rl-&gt;_ignoreWakeUps) {
        __CFRunLoopUnlock(rl);
        <span class="enscript-keyword">return</span>;
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
    kern_return_t ret;
    <span class="enscript-comment">/* We unconditionally try to send the message, since we don't want
     * to lose a wakeup, but the send may fail if there is already a
     * wakeup pending, since the queue length is 1. */</span>
    ret = __CFSendTrivialMachMessage(rl-&gt;_wakeUpPort, 0, MACH_SEND_TIMEOUT, 0);
    <span class="enscript-keyword">if</span> (ret != MACH_MSG_SUCCESS &amp;&amp; ret != MACH_SEND_TIMED_OUT) {
	HALT;
    }
#<span class="enscript-reference">else</span>
    SetEvent(rl-&gt;_wakeUpPort);
#<span class="enscript-reference">endif</span>
    __CFRunLoopUnlock(rl);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopStop</span>(CFRunLoopRef rl) {
    Boolean doWake = false;
    CHECK_FOR_FORK();
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (rl-&gt;_currentMode) {
        __CFRunLoopSetStopped(rl);
        doWake = true;
    }
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">if</span> (doWake) {
        CFRunLoopWakeUp(rl);
    }
}

CF_EXPORT <span class="enscript-type">void</span> <span class="enscript-function-name">_CFRunLoopStopMode</span>(CFRunLoopRef rl, CFStringRef modeName) {
    CHECK_FOR_FORK();
    CFRunLoopModeRef rlm;
    __CFRunLoopLock(rl);
    rlm = __CFRunLoopFindMode(rl, modeName, true);
    <span class="enscript-keyword">if</span> (NULL != rlm) {
	rlm-&gt;_stopped = true;
	__CFRunLoopModeUnlock(rlm);
    }
    __CFRunLoopUnlock(rl);
    CFRunLoopWakeUp(rl);
}

CF_EXPORT Boolean <span class="enscript-function-name">_CFRunLoopModeContainsMode</span>(CFRunLoopRef rl, CFStringRef modeName, CFStringRef candidateContainedName) {
    CHECK_FOR_FORK();
    <span class="enscript-keyword">return</span> false;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopPerformBlock</span>(CFRunLoopRef rl, CFTypeRef mode, <span class="enscript-type">void</span> (^block)(<span class="enscript-type">void</span>)) {
    CHECK_FOR_FORK();
    <span class="enscript-keyword">if</span> (CFStringGetTypeID() == CFGetTypeID(mode)) {
	mode = CFStringCreateCopy(kCFAllocatorSystemDefault, (CFStringRef)mode);
        __CFRunLoopLock(rl);
	<span class="enscript-comment">// ensure mode exists
</span>        CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)mode, true);
        <span class="enscript-keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);
        __CFRunLoopUnlock(rl);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CFArrayGetTypeID() == CFGetTypeID(mode)) {
        CFIndex cnt = CFArrayGetCount((CFArrayRef)mode);
	<span class="enscript-type">const</span> <span class="enscript-type">void</span> **values = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **)malloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *) * cnt);
        CFArrayGetValues((CFArrayRef)mode, CFRangeMake(0, cnt), values);
	mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);
        __CFRunLoopLock(rl);
	<span class="enscript-comment">// ensure modes exist
</span>	<span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);
            <span class="enscript-keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);
	}
        __CFRunLoopUnlock(rl);
	free(values);
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (CFSetGetTypeID() == CFGetTypeID(mode)) {
        CFIndex cnt = CFSetGetCount((CFSetRef)mode);
	<span class="enscript-type">const</span> <span class="enscript-type">void</span> **values = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **)malloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *) * cnt);
        CFSetGetValues((CFSetRef)mode, values);
	mode = CFSetCreate(kCFAllocatorSystemDefault, values, cnt, &amp;kCFTypeSetCallBacks);
        __CFRunLoopLock(rl);
	<span class="enscript-comment">// ensure modes exist
</span>	<span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
            CFRunLoopModeRef currentMode = __CFRunLoopFindMode(rl, (CFStringRef)values[idx], true);
            <span class="enscript-keyword">if</span> (currentMode) __CFRunLoopModeUnlock(currentMode);
	}
        __CFRunLoopUnlock(rl);
	free(values);
    } <span class="enscript-keyword">else</span> {
	mode = NULL;
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    <span class="enscript-comment">// &lt;rdar://problem/7659483&gt; clang ObjC rewriter: __typeof(block) not rewritten correctly
</span>    block = (<span class="enscript-type">void</span> (^)(<span class="enscript-type">void</span>))_Block_copy(block);
#<span class="enscript-reference">else</span>
    block = Block_copy(block);
#<span class="enscript-reference">endif</span>
    <span class="enscript-keyword">if</span> (!mode || !block) {
	<span class="enscript-keyword">if</span> (mode) CFRelease(mode);
	<span class="enscript-keyword">if</span> (block) Block_release(block);
	<span class="enscript-keyword">return</span>;
    }
    __CFRunLoopLock(rl);
    <span class="enscript-type">struct</span> _block_item *new_item = (<span class="enscript-type">struct</span> _block_item *)malloc(<span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> _block_item));
    new_item-&gt;_next = NULL;
    new_item-&gt;_mode = mode;
    new_item-&gt;_block = block;
    <span class="enscript-keyword">if</span> (!rl-&gt;_blocks_tail) {
	rl-&gt;_blocks_head = new_item;
    } <span class="enscript-keyword">else</span> {
	rl-&gt;_blocks_tail-&gt;_next = new_item;
    }
    rl-&gt;_blocks_tail = new_item;
    __CFRunLoopUnlock(rl);
}

Boolean <span class="enscript-function-name">CFRunLoopContainsSource</span>(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) {
    CHECK_FOR_FORK();
    CFRunLoopModeRef rlm;
    Boolean hasValue = false;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	<span class="enscript-keyword">if</span> (NULL != rl-&gt;_commonModeItems) {
	    hasValue = CFSetContainsValue(rl-&gt;_commonModeItems, rls);
	}
    } <span class="enscript-keyword">else</span> {
	rlm = __CFRunLoopFindMode(rl, modeName, false);
	<span class="enscript-keyword">if</span> (NULL != rlm) {
	    hasValue = (rlm-&gt;_sources0 ? CFSetContainsValue(rlm-&gt;_sources0, rls) : false) || (rlm-&gt;_sources1 ? CFSetContainsValue(rlm-&gt;_sources1, rls) : false);
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> hasValue;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopAddSource</span>(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();
    <span class="enscript-keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (!__CFIsValid(rls)) <span class="enscript-keyword">return</span>;
    Boolean doVer0Callout = false;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;
	<span class="enscript-keyword">if</span> (NULL == rl-&gt;_commonModeItems) {
	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
	}
	CFSetAddValue(rl-&gt;_commonModeItems, rls);
	<span class="enscript-keyword">if</span> (NULL != set) {
	    CFTypeRef context[2] = {rl, rls};
	    <span class="enscript-comment">/* add new item to all common-modes */</span>
	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (<span class="enscript-type">void</span> *)context);
	    CFRelease(set);
	}
    } <span class="enscript-keyword">else</span> {
	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; NULL == rlm-&gt;_sources0) {
	    rlm-&gt;_sources0 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
	    rlm-&gt;_sources1 = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
	    rlm-&gt;_portToV1SourceMap = CFDictionaryCreateMutable(kCFAllocatorSystemDefault, 0, NULL, NULL);
	}
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources0, rls) &amp;&amp; !CFSetContainsValue(rlm-&gt;_sources1, rls)) {
	    <span class="enscript-keyword">if</span> (0 == rls-&gt;_context.version0.version) {
	        CFSetAddValue(rlm-&gt;_sources0, rls);
	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (1 == rls-&gt;_context.version0.version) {
	        CFSetAddValue(rlm-&gt;_sources1, rls);
		__CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);
		<span class="enscript-keyword">if</span> (CFPORT_NULL != src_port) {
		    CFDictionarySetValue(rlm-&gt;_portToV1SourceMap, (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(uintptr_t)src_port, rls);
		    __CFPortSetInsert(src_port, rlm-&gt;_portSet);
	        }
	    }
	    __CFRunLoopSourceLock(rls);
	    <span class="enscript-keyword">if</span> (NULL == rls-&gt;_runLoops) {
	        rls-&gt;_runLoops = CFBagCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeBagCallBacks); <span class="enscript-comment">// sources retain run loops!
</span>	    }
	    CFBagAddValue(rls-&gt;_runLoops, rl);
	    __CFRunLoopSourceUnlock(rls);
	    <span class="enscript-keyword">if</span> (0 == rls-&gt;_context.version0.version) {
	        <span class="enscript-keyword">if</span> (NULL != rls-&gt;_context.version0.schedule) {
	            doVer0Callout = true;
	        }
	    }
	}
        <span class="enscript-keyword">if</span> (NULL != rlm) {
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">if</span> (doVer0Callout) {
        <span class="enscript-comment">// although it looses some protection for the source, we have no choice but
</span>        <span class="enscript-comment">// to do this after unlocking the run loop and mode locks, to avoid deadlocks
</span>        <span class="enscript-comment">// where the source wants to take a lock which is already held in another
</span>        <span class="enscript-comment">// thread which is itself waiting for a run loop/mode lock
</span>	rls-&gt;_context.version0.schedule(rls-&gt;_context.version0.info, rl, modeName);	<span class="enscript-comment">/* CALLOUT */</span>
    }
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopRemoveSource</span>(CFRunLoopRef rl, CFRunLoopSourceRef rls, CFStringRef modeName) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();
    Boolean doVer0Callout = false, doRLSRelease = false;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	<span class="enscript-keyword">if</span> (NULL != rl-&gt;_commonModeItems &amp;&amp; CFSetContainsValue(rl-&gt;_commonModeItems, rls)) {
	    CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;
	    CFSetRemoveValue(rl-&gt;_commonModeItems, rls);
	    <span class="enscript-keyword">if</span> (NULL != set) {
		CFTypeRef context[2] = {rl, rls};
		<span class="enscript-comment">/* remove new item from all common-modes */</span>
		CFSetApplyFunction(set, (__CFRunLoopRemoveItemFromCommonModes), (<span class="enscript-type">void</span> *)context);
		CFRelease(set);
	    }
	} <span class="enscript-keyword">else</span> {
	}
    } <span class="enscript-keyword">else</span> {
	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; ((NULL != rlm-&gt;_sources0 &amp;&amp; CFSetContainsValue(rlm-&gt;_sources0, rls)) || (NULL != rlm-&gt;_sources1 &amp;&amp; CFSetContainsValue(rlm-&gt;_sources1, rls)))) {
	    CFRetain(rls);
	    <span class="enscript-keyword">if</span> (1 == rls-&gt;_context.version0.version) {
		__CFPort src_port = rls-&gt;_context.version1.getPort(rls-&gt;_context.version1.info);
                <span class="enscript-keyword">if</span> (CFPORT_NULL != src_port) {
		    CFDictionaryRemoveValue(rlm-&gt;_portToV1SourceMap, (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *)(uintptr_t)src_port);
                    __CFPortSetRemove(src_port, rlm-&gt;_portSet);
                }
	    }
	    CFSetRemoveValue(rlm-&gt;_sources0, rls);
	    CFSetRemoveValue(rlm-&gt;_sources1, rls);
            __CFRunLoopSourceLock(rls);
            <span class="enscript-keyword">if</span> (NULL != rls-&gt;_runLoops) {
                CFBagRemoveValue(rls-&gt;_runLoops, rl);
            }
            __CFRunLoopSourceUnlock(rls);
	    <span class="enscript-keyword">if</span> (0 == rls-&gt;_context.version0.version) {
	        <span class="enscript-keyword">if</span> (NULL != rls-&gt;_context.version0.schedule) {
	            doVer0Callout = true;
	        }
	    }
	    doRLSRelease = true;
	}
        <span class="enscript-keyword">if</span> (NULL != rlm) {
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">if</span> (doVer0Callout) {
        <span class="enscript-comment">// although it looses some protection for the source, we have no choice but
</span>        <span class="enscript-comment">// to do this after unlocking the run loop and mode locks, to avoid deadlocks
</span>        <span class="enscript-comment">// where the source wants to take a lock which is already held in another
</span>        <span class="enscript-comment">// thread which is itself waiting for a run loop/mode lock
</span>        rls-&gt;_context.version0.cancel(rls-&gt;_context.version0.info, rl, modeName);	<span class="enscript-comment">/* CALLOUT */</span>
    }
    <span class="enscript-keyword">if</span> (doRLSRelease) CFRelease(rls);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopRemoveSourcesFromCommonMode</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *ctx) {
    CFStringRef modeName = (CFStringRef)value;
    CFRunLoopRef rl = (CFRunLoopRef)ctx;
    __CFRunLoopRemoveAllSources(rl, modeName);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopRemoveSourceFromMode</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *ctx) {
    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)value;
    CFRunLoopRef rl = (CFRunLoopRef)(((CFTypeRef *)ctx)[0]);
    CFStringRef modeName = (CFStringRef)(((CFTypeRef *)ctx)[1]);
    CFRunLoopRemoveSource(rl, rls, modeName);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopRemoveAllSources</span>(CFRunLoopRef rl, CFStringRef modeName) {
    CHECK_FOR_FORK();
    CFRunLoopModeRef rlm;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	<span class="enscript-keyword">if</span> (NULL != rl-&gt;_commonModeItems) {
	    CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;
	    <span class="enscript-keyword">if</span> (NULL != set) {
                CFSetApplyFunction(set, (__CFRunLoopRemoveSourcesFromCommonMode), (<span class="enscript-type">void</span> *)rl);
		CFRelease(set);
	    }
	} <span class="enscript-keyword">else</span> {
	}
    } <span class="enscript-keyword">else</span> {
	rlm = __CFRunLoopFindMode(rl, modeName, false);
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; NULL != rlm-&gt;_sources0) {
	    CFSetRef set = CFSetCreateCopy(kCFAllocatorSystemDefault, rlm-&gt;_sources0);
            CFTypeRef context[2] = {rl, modeName};
            CFSetApplyFunction(set, (__CFRunLoopRemoveSourceFromMode), (<span class="enscript-type">void</span> *)context);
	    CFRelease(set);
	}
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; NULL != rlm-&gt;_sources1) {
	    CFSetRef set = CFSetCreateCopy(kCFAllocatorSystemDefault, rlm-&gt;_sources1);
            CFTypeRef context[2] = {rl, modeName};
            CFSetApplyFunction(set, (__CFRunLoopRemoveSourceFromMode), (<span class="enscript-type">void</span> *)context);
	    CFRelease(set);
	}
        <span class="enscript-keyword">if</span> (NULL != rlm) {
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
}

Boolean <span class="enscript-function-name">CFRunLoopContainsObserver</span>(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) {
    CHECK_FOR_FORK();
    CFRunLoopModeRef rlm;
    Boolean hasValue = false;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	<span class="enscript-keyword">if</span> (NULL != rl-&gt;_commonModeItems) {
	    hasValue = CFSetContainsValue(rl-&gt;_commonModeItems, rlo);
	}
    } <span class="enscript-keyword">else</span> {
	rlm = __CFRunLoopFindMode(rl, modeName, false);
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; NULL != rlm-&gt;_observers) {
	    hasValue = CFArrayContainsValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo);
	}
        <span class="enscript-keyword">if</span> (NULL != rlm) {
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> hasValue;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopAddObserver</span>(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) {
    CHECK_FOR_FORK();
    CFRunLoopModeRef rlm;
    <span class="enscript-keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (!__CFIsValid(rlo) || (NULL != rlo-&gt;_runLoop &amp;&amp; rlo-&gt;_runLoop != rl)) <span class="enscript-keyword">return</span>;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;
	<span class="enscript-keyword">if</span> (NULL == rl-&gt;_commonModeItems) {
	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
	}
	CFSetAddValue(rl-&gt;_commonModeItems, rlo);
	<span class="enscript-keyword">if</span> (NULL != set) {
	    CFTypeRef context[2] = {rl, rlo};
	    <span class="enscript-comment">/* add new item to all common-modes */</span>
	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (<span class="enscript-type">void</span> *)context);
	    CFRelease(set);
	}
    } <span class="enscript-keyword">else</span> {
	rlm = __CFRunLoopFindMode(rl, modeName, true);
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; NULL == rlm-&gt;_observers) {
	    rlm-&gt;_observers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeArrayCallBacks);
	}
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; !CFArrayContainsValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo)) {
            Boolean inserted = false;
            <span class="enscript-keyword">for</span> (CFIndex idx = CFArrayGetCount(rlm-&gt;_observers); idx--; ) {
                CFRunLoopObserverRef obs = (CFRunLoopObserverRef)CFArrayGetValueAtIndex(rlm-&gt;_observers, idx);
                <span class="enscript-keyword">if</span> (obs-&gt;_order &lt;= rlo-&gt;_order) {
                    CFArrayInsertValueAtIndex(rlm-&gt;_observers, idx + 1, rlo);
                    inserted = true;
                    <span class="enscript-keyword">break</span>;
                }
            }
            <span class="enscript-keyword">if</span> (!inserted) {
	        CFArrayInsertValueAtIndex(rlm-&gt;_observers, 0, rlo);
            }
	    rlm-&gt;_observerMask |= rlo-&gt;_activities;
	    __CFRunLoopObserverSchedule(rlo, rl, rlm);
	}
        <span class="enscript-keyword">if</span> (NULL != rlm) {
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopRemoveObserver</span>(CFRunLoopRef rl, CFRunLoopObserverRef rlo, CFStringRef modeName) {
    CHECK_FOR_FORK();
    CFRunLoopModeRef rlm;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	<span class="enscript-keyword">if</span> (NULL != rl-&gt;_commonModeItems &amp;&amp; CFSetContainsValue(rl-&gt;_commonModeItems, rlo)) {
	    CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;
	    CFSetRemoveValue(rl-&gt;_commonModeItems, rlo);
	    <span class="enscript-keyword">if</span> (NULL != set) {
		CFTypeRef context[2] = {rl, rlo};
		<span class="enscript-comment">/* remove new item from all common-modes */</span>
		CFSetApplyFunction(set, (__CFRunLoopRemoveItemFromCommonModes), (<span class="enscript-type">void</span> *)context);
		CFRelease(set);
	    }
	} <span class="enscript-keyword">else</span> {
	}
    } <span class="enscript-keyword">else</span> {
	rlm = __CFRunLoopFindMode(rl, modeName, false);
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; NULL != rlm-&gt;_observers) {
	    CFRetain(rlo);
            CFIndex idx = CFArrayGetFirstIndexOfValue(rlm-&gt;_observers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_observers)), rlo);
            <span class="enscript-keyword">if</span> (kCFNotFound != idx) {
                CFArrayRemoveValueAtIndex(rlm-&gt;_observers, idx);
	        __CFRunLoopObserverCancel(rlo, rl, rlm);
            }
	    CFRelease(rlo);
	}
        <span class="enscript-keyword">if</span> (NULL != rlm) {
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
}

Boolean <span class="enscript-function-name">CFRunLoopContainsTimer</span>(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {
    CHECK_FOR_FORK();
    <span class="enscript-keyword">if</span> (NULL == rlt-&gt;_runLoop || rl != rlt-&gt;_runLoop) <span class="enscript-keyword">return</span> false;
    Boolean hasValue = false;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	<span class="enscript-keyword">if</span> (NULL != rl-&gt;_commonModeItems) {
	    hasValue = CFSetContainsValue(rl-&gt;_commonModeItems, rlt);
	}
    } <span class="enscript-keyword">else</span> {
	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; NULL != rlm-&gt;_timers) {
            CFIndex idx = CFArrayGetFirstIndexOfValue(rlm-&gt;_timers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_timers)), rlt);
            hasValue = (kCFNotFound != idx);
	} 
        <span class="enscript-keyword">if</span> (NULL != rlm) {
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
    <span class="enscript-keyword">return</span> hasValue;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopAddTimer</span>(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {
    CHECK_FOR_FORK();
    <span class="enscript-keyword">if</span> (__CFRunLoopIsDeallocating(rl)) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (!__CFIsValid(rlt) || (NULL != rlt-&gt;_runLoop &amp;&amp; rlt-&gt;_runLoop != rl)) <span class="enscript-keyword">return</span>;
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;
	<span class="enscript-keyword">if</span> (NULL == rl-&gt;_commonModeItems) {
	    rl-&gt;_commonModeItems = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
	}
	CFSetAddValue(rl-&gt;_commonModeItems, rlt);
	<span class="enscript-keyword">if</span> (NULL != set) {
	    CFTypeRef context[2] = {rl, rlt};
	    <span class="enscript-comment">/* add new item to all common-modes */</span>
	    CFSetApplyFunction(set, (__CFRunLoopAddItemToCommonModes), (<span class="enscript-type">void</span> *)context);
	    CFRelease(set);
	}
    } <span class="enscript-keyword">else</span> {
	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, true);
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; NULL == rlm-&gt;_timers) {
	    CFArrayCallBacks cb = kCFTypeArrayCallBacks;
	    cb.equal = NULL;
	    rlm-&gt;_timers = CFArrayCreateMutable(kCFAllocatorSystemDefault, 0, &amp;cb);
	}
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; !CFSetContainsValue(rlt-&gt;_rlModes, rlm-&gt;_name)) {
            __CFRunLoopTimerLock(rlt);
            <span class="enscript-keyword">if</span> (NULL == rlt-&gt;_runLoop) {
		rlt-&gt;_runLoop = rl;
  	    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (rl != rlt-&gt;_runLoop) {
                __CFRunLoopTimerUnlock(rlt);
	        __CFRunLoopModeUnlock(rlm);
                __CFRunLoopUnlock(rl);
		<span class="enscript-keyword">return</span>;
	    }
  	    CFSetAddValue(rlt-&gt;_rlModes, rlm-&gt;_name);
            __CFRunLoopTimerUnlock(rlt);
            __CFRunLoopTimerFireTSRLock();
	    __CFRepositionTimerInMode(rlm, rlt, false);
            __CFRunLoopTimerFireTSRUnlock();
            <span class="enscript-keyword">if</span> (!_CFExecutableLinkedOnOrAfter(CFSystemVersionLion)) {
                <span class="enscript-comment">// Normally we don't do this on behalf of clients, but for
</span>                <span class="enscript-comment">// backwards compatibility due to the change in timer handling...
</span>                <span class="enscript-keyword">if</span> (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);
            }
	}
        <span class="enscript-keyword">if</span> (NULL != rlm) {
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopRemoveTimer</span>(CFRunLoopRef rl, CFRunLoopTimerRef rlt, CFStringRef modeName) {
    CHECK_FOR_FORK();
    __CFRunLoopLock(rl);
    <span class="enscript-keyword">if</span> (modeName == kCFRunLoopCommonModes) {
	<span class="enscript-keyword">if</span> (NULL != rl-&gt;_commonModeItems &amp;&amp; CFSetContainsValue(rl-&gt;_commonModeItems, rlt)) {
	    CFSetRef set = rl-&gt;_commonModes ? CFSetCreateCopy(kCFAllocatorSystemDefault, rl-&gt;_commonModes) : NULL;
	    CFSetRemoveValue(rl-&gt;_commonModeItems, rlt);
	    <span class="enscript-keyword">if</span> (NULL != set) {
		CFTypeRef context[2] = {rl, rlt};
		<span class="enscript-comment">/* remove new item from all common-modes */</span>
		CFSetApplyFunction(set, (__CFRunLoopRemoveItemFromCommonModes), (<span class="enscript-type">void</span> *)context);
		CFRelease(set);
	    }
	} <span class="enscript-keyword">else</span> {
	}
    } <span class="enscript-keyword">else</span> {
	CFRunLoopModeRef rlm = __CFRunLoopFindMode(rl, modeName, false);
        CFIndex idx = kCFNotFound;
	<span class="enscript-keyword">if</span> (NULL != rlm &amp;&amp; NULL != rlm-&gt;_timers) {
            idx = CFArrayGetFirstIndexOfValue(rlm-&gt;_timers, CFRangeMake(0, CFArrayGetCount(rlm-&gt;_timers)), rlt);
        }
        <span class="enscript-keyword">if</span> (kCFNotFound != idx) {
            __CFRunLoopTimerLock(rlt);
            CFSetRemoveValue(rlt-&gt;_rlModes, rlm-&gt;_name);
            <span class="enscript-keyword">if</span> (0 == CFSetGetCount(rlt-&gt;_rlModes)) {
                rlt-&gt;_runLoop = NULL;
            }
            __CFRunLoopTimerUnlock(rlt);
	    CFArrayRemoveValueAtIndex(rlm-&gt;_timers, idx);
            <span class="enscript-keyword">if</span> (0 == CFArrayGetCount(rlm-&gt;_timers)) {
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
                AbsoluteTime dummy;
                mk_timer_cancel(rlm-&gt;_timerPort, &amp;dummy);
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
                CancelWaitableTimer(rlm-&gt;_timerPort);
#<span class="enscript-reference">endif</span>
            } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (0 == idx) {
                CFRunLoopTimerRef nextTimer = NULL;
                <span class="enscript-keyword">for</span> (CFIndex idx = 0, cnt = CFArrayGetCount(rlm-&gt;_timers); idx &lt; cnt; idx++) {
                    CFRunLoopTimerRef t = (CFRunLoopTimerRef)CFArrayGetValueAtIndex(rlm-&gt;_timers, idx);
                    <span class="enscript-keyword">if</span> (!__CFRunLoopTimerIsFiring(t)) {
                        nextTimer = t;
                        <span class="enscript-keyword">break</span>;
                    }
                }
                <span class="enscript-keyword">if</span> (nextTimer) {
		    int64_t fireTSR = nextTimer-&gt;_fireTSR;
		    fireTSR = (fireTSR / tenus + 1) * tenus;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
		    mk_timer_arm(rlm-&gt;_timerPort, __CFUInt64ToAbsoluteTime(fireTSR));
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
                    LARGE_INTEGER dueTime;
                    dueTime.QuadPart = __CFTSRToFiletime(fireTSR);
                    SetWaitableTimer(rlm-&gt;_timerPort, &amp;dueTime, 0, NULL, NULL, FALSE);
#<span class="enscript-reference">endif</span>
                }
            }
	}
        <span class="enscript-keyword">if</span> (NULL != rlm) {
	    __CFRunLoopModeUnlock(rlm);
	}
    }
    __CFRunLoopUnlock(rl);
}

<span class="enscript-comment">/* CFRunLoopSource */</span>

<span class="enscript-type">static</span> Boolean <span class="enscript-function-name">__CFRunLoopSourceEqual</span>(CFTypeRef cf1, CFTypeRef cf2) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CFRunLoopSourceRef rls1 = (CFRunLoopSourceRef)cf1;
    CFRunLoopSourceRef rls2 = (CFRunLoopSourceRef)cf2;
    <span class="enscript-keyword">if</span> (rls1 == rls2) <span class="enscript-keyword">return</span> true;
    <span class="enscript-keyword">if</span> (__CFIsValid(rls1) != __CFIsValid(rls2)) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (rls1-&gt;_order != rls2-&gt;_order) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (rls1-&gt;_context.version0.version != rls2-&gt;_context.version0.version) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (rls1-&gt;_context.version0.hash != rls2-&gt;_context.version0.hash) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (rls1-&gt;_context.version0.equal != rls2-&gt;_context.version0.equal) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (0 == rls1-&gt;_context.version0.version &amp;&amp; rls1-&gt;_context.version0.perform != rls2-&gt;_context.version0.perform) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (1 == rls1-&gt;_context.version0.version &amp;&amp; rls1-&gt;_context.version1.perform != rls2-&gt;_context.version1.perform) <span class="enscript-keyword">return</span> false;
    <span class="enscript-keyword">if</span> (rls1-&gt;_context.version0.equal)
	<span class="enscript-keyword">return</span> rls1-&gt;_context.version0.equal(rls1-&gt;_context.version0.info, rls2-&gt;_context.version0.info);
    <span class="enscript-keyword">return</span> (rls1-&gt;_context.version0.info == rls2-&gt;_context.version0.info);
}

<span class="enscript-type">static</span> CFHashCode <span class="enscript-function-name">__CFRunLoopSourceHash</span>(CFTypeRef cf) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)cf;
    <span class="enscript-keyword">if</span> (rls-&gt;_context.version0.hash)
	<span class="enscript-keyword">return</span> rls-&gt;_context.version0.hash(rls-&gt;_context.version0.info);
    <span class="enscript-keyword">return</span> (CFHashCode)rls-&gt;_context.version0.info;
}

<span class="enscript-type">static</span> CFStringRef <span class="enscript-function-name">__CFRunLoopSourceCopyDescription</span>(CFTypeRef cf) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)cf;
    CFStringRef result;
    CFStringRef contextDesc = NULL;
    <span class="enscript-keyword">if</span> (NULL != rls-&gt;_context.version0.copyDescription) {
	contextDesc = rls-&gt;_context.version0.copyDescription(rls-&gt;_context.version0.info);
    }
    <span class="enscript-keyword">if</span> (NULL == contextDesc) {
	<span class="enscript-type">void</span> *addr = rls-&gt;_context.version0.version == 0 ? (<span class="enscript-type">void</span> *)rls-&gt;_context.version0.perform : (rls-&gt;_context.version0.version == 1 ? (<span class="enscript-type">void</span> *)rls-&gt;_context.version1.perform : NULL);
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
	contextDesc = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopSource context&gt;{version = %ld, info = %p, callout = %p}"</span>), rls-&gt;_context.version0.version, rls-&gt;_context.version0.info, addr);
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
	Dl_info info;
	<span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = (dladdr(addr, &amp;info) &amp;&amp; info.dli_saddr == addr &amp;&amp; info.dli_sname) ? info.dli_sname : <span class="enscript-string">"???"</span>;
	contextDesc = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopSource context&gt;{version = %ld, info = %p, callout = %s (%p)}"</span>), rls-&gt;_context.version0.version, rls-&gt;_context.version0.info, name, addr);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">or</span> <span class="enscript-variable-name">unspecified</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET</span>
#<span class="enscript-reference">endif</span>
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    result = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopSource %p [%p]&gt;{signalled = %s, valid = %s, order = %d, context = %@}"</span>), cf, CFGetAllocator(rls), __CFRunLoopSourceIsSignaled(rls) ? <span class="enscript-string">"Yes"</span> : <span class="enscript-string">"No"</span>, __CFIsValid(rls) ? <span class="enscript-string">"Yes"</span> : <span class="enscript-string">"No"</span>, rls-&gt;_order, contextDesc);
#<span class="enscript-reference">else</span>
    result = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopSource %p [%p]&gt;{signalled = %s, valid = %s, order = %d, context = %@}"</span>), cf, CFGetAllocator(rls), __CFRunLoopSourceIsSignaled(rls) ? <span class="enscript-string">"Yes"</span> : <span class="enscript-string">"No"</span>, __CFIsValid(rls) ? <span class="enscript-string">"Yes"</span> : <span class="enscript-string">"No"</span>, rls-&gt;_order, contextDesc);
#<span class="enscript-reference">endif</span>
    CFRelease(contextDesc);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSourceDeallocate</span>(CFTypeRef cf) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)cf;
    CFRunLoopSourceInvalidate(rls);
    <span class="enscript-keyword">if</span> (rls-&gt;_context.version0.release) {
	rls-&gt;_context.version0.release(rls-&gt;_context.version0.info);
    }
    pthread_mutex_destroy(&amp;rls-&gt;_lock);
    memset((<span class="enscript-type">char</span> *)cf + <span class="enscript-keyword">sizeof</span>(CFRuntimeBase), 0, <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> __CFRunLoopSource) - <span class="enscript-keyword">sizeof</span>(CFRuntimeBase));
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> CFRuntimeClass __CFRunLoopSourceClass = {
    _kCFRuntimeScannedObject,
    <span class="enscript-string">"CFRunLoopSource"</span>,
    NULL,      <span class="enscript-comment">// init
</span>    NULL,      <span class="enscript-comment">// copy
</span>    __CFRunLoopSourceDeallocate,
    __CFRunLoopSourceEqual,
    __CFRunLoopSourceHash,
    NULL,      <span class="enscript-comment">// 
</span>    __CFRunLoopSourceCopyDescription
};

__private_extern__ <span class="enscript-type">void</span> __CFRunLoopSourceInitialize(<span class="enscript-type">void</span>) {
    __kCFRunLoopSourceTypeID = _CFRuntimeRegisterClass(&amp;__CFRunLoopSourceClass);
}

CFTypeID <span class="enscript-function-name">CFRunLoopSourceGetTypeID</span>(<span class="enscript-type">void</span>) {
    <span class="enscript-keyword">return</span> __kCFRunLoopSourceTypeID;
}

CFRunLoopSourceRef <span class="enscript-function-name">CFRunLoopSourceCreate</span>(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context) {
    CHECK_FOR_FORK();
    CFRunLoopSourceRef memory;
    uint32_t size;
    <span class="enscript-keyword">if</span> (NULL == context) HALT;
    size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> __CFRunLoopSource) - <span class="enscript-keyword">sizeof</span>(CFRuntimeBase);
    memory = (CFRunLoopSourceRef)_CFRuntimeCreateInstance(allocator, __kCFRunLoopSourceTypeID, size, NULL);
    <span class="enscript-keyword">if</span> (NULL == memory) {
	<span class="enscript-keyword">return</span> NULL;
    }
    __CFSetValid(memory);
    __CFRunLoopSourceUnsetSignaled(memory);
    __CFRunLoopLockInit(&amp;memory-&gt;_lock);
    memory-&gt;_bits = 0;
    memory-&gt;_order = order;
    memory-&gt;_runLoops = NULL;
    size = 0;
    <span class="enscript-keyword">switch</span> (context-&gt;version) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
	size = <span class="enscript-keyword">sizeof</span>(CFRunLoopSourceContext);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	size = <span class="enscript-keyword">sizeof</span>(CFRunLoopSourceContext1);
	<span class="enscript-keyword">break</span>;
    }
    objc_memmove_collectable(&amp;memory-&gt;_context, context, size);
    <span class="enscript-keyword">if</span> (context-&gt;retain) {
	memory-&gt;_context.version0.info = (<span class="enscript-type">void</span> *)context-&gt;retain(context-&gt;info);
    }
    <span class="enscript-keyword">return</span> memory;
}

CFIndex <span class="enscript-function-name">CFRunLoopSourceGetOrder</span>(CFRunLoopSourceRef rls) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rls, __kCFRunLoopSourceTypeID);
    <span class="enscript-keyword">return</span> rls-&gt;_order;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSourceWakeUpLoop</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *context) {
    CFRunLoopWakeUp((CFRunLoopRef)value);
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopSourceRemoveFromRunLoop</span>(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *value, <span class="enscript-type">void</span> *context) {
    CFRunLoopRef rl = (CFRunLoopRef)value;
    CFTypeRef *params = (CFTypeRef *)context;
    CFRunLoopSourceRef rls = (CFRunLoopSourceRef)params[0];
    CFIndex idx;
    <span class="enscript-keyword">if</span> (rl == params[1]) <span class="enscript-keyword">return</span>;

    <span class="enscript-comment">// CFRunLoopRemoveSource will lock the run loop while it
</span>    <span class="enscript-comment">// needs that, but we also lock it out here to keep
</span>    <span class="enscript-comment">// changes from occurring for this whole sequence.
</span>    __CFRunLoopLock(rl);
    CFArrayRef array = CFRunLoopCopyAllModes(rl);
    <span class="enscript-keyword">for</span> (idx = CFArrayGetCount(array); idx--;) {
	CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);
	CFRunLoopRemoveSource(rl, rls, modeName);
    }
    CFRunLoopRemoveSource(rl, rls, kCFRunLoopCommonModes);
    __CFRunLoopUnlock(rl);
    CFRelease(array);
    params[1] = rl;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopSourceInvalidate</span>(CFRunLoopSourceRef rls) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rls, __kCFRunLoopSourceTypeID);
    __CFRunLoopSourceLock(rls);
    CFRetain(rls);
    <span class="enscript-keyword">if</span> (__CFIsValid(rls)) {
        CFBagRef rloops = rls-&gt;_runLoops;
        __CFUnsetValid(rls);
        __CFRunLoopSourceUnsetSignaled(rls);
        <span class="enscript-keyword">if</span> (NULL != rloops) {
            <span class="enscript-comment">// To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up
</span>            <span class="enscript-comment">// towards the run loop from a source, the source has to be
</span>            <span class="enscript-comment">// unlocked, which means we have to protect from object
</span>            <span class="enscript-comment">// invalidation.
</span>            rls-&gt;_runLoops = NULL; <span class="enscript-comment">// transfer ownership to local stack
</span>            __CFRunLoopSourceUnlock(rls);
            CFTypeRef params[2] = {rls, NULL};
            CFBagApplyFunction(rloops, (__CFRunLoopSourceRemoveFromRunLoop), params);
            CFRelease(rloops);
            __CFRunLoopSourceLock(rls);
        }
        <span class="enscript-comment">/* for hashing- and equality-use purposes, can't actually release the context here */</span>
    }
    __CFRunLoopSourceUnlock(rls);
    CFRelease(rls);
}

Boolean <span class="enscript-function-name">CFRunLoopSourceIsValid</span>(CFRunLoopSourceRef rls) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rls, __kCFRunLoopSourceTypeID);
    <span class="enscript-keyword">return</span> __CFIsValid(rls);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopSourceGetContext</span>(CFRunLoopSourceRef rls, CFRunLoopSourceContext *context) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rls, __kCFRunLoopSourceTypeID);
    CFAssert1(0 == context-&gt;version || 1 == context-&gt;version, __kCFLogAssertion, <span class="enscript-string">"%s(): context version not initialized to 0 or 1"</span>, __PRETTY_FUNCTION__);
    CFIndex size = 0;
    <span class="enscript-keyword">switch</span> (context-&gt;version) {
    <span class="enscript-keyword">case</span> <span class="enscript-reference">0</span>:
	size = <span class="enscript-keyword">sizeof</span>(CFRunLoopSourceContext);
	<span class="enscript-keyword">break</span>;
    <span class="enscript-keyword">case</span> <span class="enscript-reference">1</span>:
	size = <span class="enscript-keyword">sizeof</span>(CFRunLoopSourceContext1);
	<span class="enscript-keyword">break</span>;
    }
    memmove(context, &amp;rls-&gt;_context, size);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopSourceSignal</span>(CFRunLoopSourceRef rls) {
    CHECK_FOR_FORK();
    __CFRunLoopSourceLock(rls);
    <span class="enscript-keyword">if</span> (__CFIsValid(rls)) {
	__CFRunLoopSourceSetSignaled(rls);
    }
    __CFRunLoopSourceUnlock(rls);
}

Boolean <span class="enscript-function-name">CFRunLoopSourceIsSignalled</span>(CFRunLoopSourceRef rls) {
    CHECK_FOR_FORK();
    __CFRunLoopSourceLock(rls);
    Boolean ret = __CFRunLoopSourceIsSignaled(rls) ? true : false;
    __CFRunLoopSourceUnlock(rls);
    <span class="enscript-keyword">return</span> ret;
}

__private_extern__ <span class="enscript-type">void</span> _CFRunLoopSourceWakeUpRunLoops(CFRunLoopSourceRef rls) {
    CFBagRef loops = NULL;
    __CFRunLoopSourceLock(rls);
    <span class="enscript-keyword">if</span> (__CFIsValid(rls) &amp;&amp; NULL != rls-&gt;_runLoops) {
        loops = CFBagCreateCopy(kCFAllocatorSystemDefault, rls-&gt;_runLoops);
    }
    __CFRunLoopSourceUnlock(rls);
    <span class="enscript-keyword">if</span> (loops) {
	CFBagApplyFunction(loops, __CFRunLoopSourceWakeUpLoop, NULL);
        CFRelease(loops);
    }
}

<span class="enscript-comment">/* CFRunLoopObserver */</span>

<span class="enscript-type">static</span> CFStringRef <span class="enscript-function-name">__CFRunLoopObserverCopyDescription</span>(CFTypeRef cf) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)cf;
    CFStringRef result;
    CFStringRef contextDesc = NULL;
    <span class="enscript-keyword">if</span> (NULL != rlo-&gt;_context.copyDescription) {
	contextDesc = rlo-&gt;_context.copyDescription(rlo-&gt;_context.info);
    }
    <span class="enscript-keyword">if</span> (!contextDesc) {
	contextDesc = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopObserver context %p&gt;"</span>), rlo-&gt;_context.info);
    }
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
    result = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopObserver %p [%p]&gt;{valid = %s, activities = 0x%x, repeats = %s, order = %d, callout = %p, context = %@}"</span>), cf, CFGetAllocator(rlo), __CFIsValid(rlo) ? <span class="enscript-string">"Yes"</span> : <span class="enscript-string">"No"</span>, rlo-&gt;_activities, __CFRunLoopObserverRepeats(rlo) ? <span class="enscript-string">"Yes"</span> : <span class="enscript-string">"No"</span>, rlo-&gt;_order, rlo-&gt;_callout, contextDesc);    
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
    <span class="enscript-type">void</span> *addr = rlo-&gt;_callout;
    Dl_info info;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = (dladdr(addr, &amp;info) &amp;&amp; info.dli_saddr == addr &amp;&amp; info.dli_sname) ? info.dli_sname : <span class="enscript-string">"???"</span>;
    result = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopObserver %p [%p]&gt;{valid = %s, activities = 0x%x, repeats = %s, order = %d, callout = %s (%p), context = %@}"</span>), cf, CFGetAllocator(rlo), __CFIsValid(rlo) ? <span class="enscript-string">"Yes"</span> : <span class="enscript-string">"No"</span>, rlo-&gt;_activities, __CFRunLoopObserverRepeats(rlo) ? <span class="enscript-string">"Yes"</span> : <span class="enscript-string">"No"</span>, rlo-&gt;_order, name, addr, contextDesc);
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">or</span> <span class="enscript-variable-name">unspecified</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET</span>
#<span class="enscript-reference">endif</span>
    CFRelease(contextDesc);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopObserverDeallocate</span>(CFTypeRef cf) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CFRunLoopObserverRef rlo = (CFRunLoopObserverRef)cf;
    CFRunLoopObserverInvalidate(rlo);
    pthread_mutex_destroy(&amp;rlo-&gt;_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> CFRuntimeClass __CFRunLoopObserverClass = {
    0,
    <span class="enscript-string">"CFRunLoopObserver"</span>,
    NULL,      <span class="enscript-comment">// init
</span>    NULL,      <span class="enscript-comment">// copy
</span>    __CFRunLoopObserverDeallocate,
    NULL,
    NULL,
    NULL,      <span class="enscript-comment">// 
</span>    __CFRunLoopObserverCopyDescription
};

__private_extern__ <span class="enscript-type">void</span> __CFRunLoopObserverInitialize(<span class="enscript-type">void</span>) {
    __kCFRunLoopObserverTypeID = _CFRuntimeRegisterClass(&amp;__CFRunLoopObserverClass);
}

CFTypeID <span class="enscript-function-name">CFRunLoopObserverGetTypeID</span>(<span class="enscript-type">void</span>) {
    <span class="enscript-keyword">return</span> __kCFRunLoopObserverTypeID;
}

CFRunLoopObserverRef <span class="enscript-function-name">CFRunLoopObserverCreate</span>(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, CFRunLoopObserverCallBack callout, CFRunLoopObserverContext *context) {
    CHECK_FOR_FORK();
    CFRunLoopObserverRef memory;
    UInt32 size;
    size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> __CFRunLoopObserver) - <span class="enscript-keyword">sizeof</span>(CFRuntimeBase);
    memory = (CFRunLoopObserverRef)_CFRuntimeCreateInstance(allocator, __kCFRunLoopObserverTypeID, size, NULL);
    <span class="enscript-keyword">if</span> (NULL == memory) {
	<span class="enscript-keyword">return</span> NULL;
    }
    __CFSetValid(memory);
    __CFRunLoopObserverUnsetFiring(memory);
    <span class="enscript-keyword">if</span> (repeats) {
	__CFRunLoopObserverSetRepeats(memory);
    } <span class="enscript-keyword">else</span> {
	__CFRunLoopObserverUnsetRepeats(memory);
    }
    __CFRunLoopLockInit(&amp;memory-&gt;_lock);
    memory-&gt;_runLoop = NULL;
    memory-&gt;_rlCount = 0;
    memory-&gt;_activities = activities;
    memory-&gt;_order = order;
    memory-&gt;_callout = callout;
    <span class="enscript-keyword">if</span> (context) {
	<span class="enscript-keyword">if</span> (context-&gt;retain) {
	    memory-&gt;_context.info = (<span class="enscript-type">void</span> *)context-&gt;retain(context-&gt;info);
	} <span class="enscript-keyword">else</span> {
	    memory-&gt;_context.info = context-&gt;info;
	}
	memory-&gt;_context.retain = context-&gt;retain;
	memory-&gt;_context.release = context-&gt;release;
	memory-&gt;_context.copyDescription = context-&gt;copyDescription;
    } <span class="enscript-keyword">else</span> {
	memory-&gt;_context.info = 0;
	memory-&gt;_context.retain = 0;
	memory-&gt;_context.release = 0;
	memory-&gt;_context.copyDescription = 0;
    }
    <span class="enscript-keyword">return</span> memory;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">_runLoopObserverWithBlockContext</span>(CFRunLoopObserverRef observer, CFRunLoopActivity activity, <span class="enscript-type">void</span> *opaqueBlock) {
    <span class="enscript-type">typedef</span> <span class="enscript-type">void</span> (^observer_block_t) (CFRunLoopObserverRef observer, CFRunLoopActivity activity);
    observer_block_t block = (observer_block_t)opaqueBlock;
    block(observer, activity);
}

CFRunLoopObserverRef <span class="enscript-function-name">CFRunLoopObserverCreateWithHandler</span>(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order,
                                                      <span class="enscript-type">void</span> (^block) (CFRunLoopObserverRef observer, CFRunLoopActivity activity)) {
    CFRunLoopObserverContext blockContext;
    blockContext.version = 0;
    blockContext.info = (<span class="enscript-type">void</span> *)block;
    blockContext.retain = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *(*)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *info))_Block_copy;
    blockContext.release = (<span class="enscript-type">void</span> (*)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *info))_Block_release;
    blockContext.copyDescription = NULL;
    <span class="enscript-keyword">return</span> CFRunLoopObserverCreate(allocator, activities, repeats, order, _runLoopObserverWithBlockContext, &amp;blockContext);
}

CFOptionFlags <span class="enscript-function-name">CFRunLoopObserverGetActivities</span>(CFRunLoopObserverRef rlo) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rlo, __kCFRunLoopObserverTypeID);
    <span class="enscript-keyword">return</span> rlo-&gt;_activities;
}

CFIndex <span class="enscript-function-name">CFRunLoopObserverGetOrder</span>(CFRunLoopObserverRef rlo) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rlo, __kCFRunLoopObserverTypeID);
    <span class="enscript-keyword">return</span> rlo-&gt;_order;
}

Boolean <span class="enscript-function-name">CFRunLoopObserverDoesRepeat</span>(CFRunLoopObserverRef rlo) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rlo, __kCFRunLoopObserverTypeID);
    <span class="enscript-keyword">return</span> __CFRunLoopObserverRepeats(rlo);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopObserverInvalidate</span>(CFRunLoopObserverRef rlo) {    <span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();
    __CFGenericValidateType(rlo, __kCFRunLoopObserverTypeID);
    __CFRunLoopObserverLock(rlo);
    CFRetain(rlo);
    <span class="enscript-keyword">if</span> (__CFIsValid(rlo)) {
        CFRunLoopRef rl = rlo-&gt;_runLoop;
        <span class="enscript-type">void</span> *info = rlo-&gt;_context.info;
        rlo-&gt;_context.info = NULL;
        __CFUnsetValid(rlo);
        <span class="enscript-keyword">if</span> (NULL != rl) {
            <span class="enscript-comment">// To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up
</span>            <span class="enscript-comment">// towards the run loop from an observer, it has to be
</span>            <span class="enscript-comment">// unlocked, which means we have to protect from object
</span>            <span class="enscript-comment">// invalidation.
</span>            CFRetain(rl);
            __CFRunLoopObserverUnlock(rlo);
            <span class="enscript-comment">// CFRunLoopRemoveObserver will lock the run loop while it
</span>            <span class="enscript-comment">// needs that, but we also lock it out here to keep
</span>            <span class="enscript-comment">// changes from occurring for this whole sequence.
</span>            __CFRunLoopLock(rl);
            CFArrayRef array = CFRunLoopCopyAllModes(rl);
            <span class="enscript-keyword">for</span> (CFIndex idx = CFArrayGetCount(array); idx--;) {
                CFStringRef modeName = (CFStringRef)CFArrayGetValueAtIndex(array, idx);
                CFRunLoopRemoveObserver(rl, rlo, modeName);
            }
            CFRunLoopRemoveObserver(rl, rlo, kCFRunLoopCommonModes);
            __CFRunLoopUnlock(rl);
            CFRelease(array);
            CFRelease(rl);
            __CFRunLoopObserverLock(rlo);
        }
        <span class="enscript-keyword">if</span> (NULL != rlo-&gt;_context.release) {
            rlo-&gt;_context.release(info);        <span class="enscript-comment">/* CALLOUT */</span>
        }
    }
    __CFRunLoopObserverUnlock(rlo);
    CFRelease(rlo);
}

Boolean <span class="enscript-function-name">CFRunLoopObserverIsValid</span>(CFRunLoopObserverRef rlo) {
    CHECK_FOR_FORK();
    <span class="enscript-keyword">return</span> __CFIsValid(rlo);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopObserverGetContext</span>(CFRunLoopObserverRef rlo, CFRunLoopObserverContext *context) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rlo, __kCFRunLoopObserverTypeID);
    CFAssert1(0 == context-&gt;version, __kCFLogAssertion, <span class="enscript-string">"%s(): context version not initialized to 0"</span>, __PRETTY_FUNCTION__);
    *context = rlo-&gt;_context;
}

<span class="enscript-comment">/* CFRunLoopTimer */</span>

<span class="enscript-type">static</span> CFStringRef <span class="enscript-function-name">__CFRunLoopTimerCopyDescription</span>(CFTypeRef cf) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)cf;
    CFStringRef contextDesc = NULL;
    <span class="enscript-keyword">if</span> (NULL != rlt-&gt;_context.copyDescription) {
	contextDesc = rlt-&gt;_context.copyDescription(rlt-&gt;_context.info);
    }
    <span class="enscript-keyword">if</span> (NULL == contextDesc) {
	contextDesc = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopTimer context %p&gt;"</span>), rlt-&gt;_context.info);
    }
    <span class="enscript-type">void</span> *addr = (<span class="enscript-type">void</span> *)rlt-&gt;_callout;
    <span class="enscript-type">const</span> <span class="enscript-type">char</span> *name = <span class="enscript-string">"???"</span>;
#<span class="enscript-reference">if</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_WINDOWS</span>
#<span class="enscript-reference">elif</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET_MACOSX</span> || <span class="enscript-variable-name">DEPLOYMENT_TARGET_EMBEDDED</span>
    Dl_info info;
    name = (dladdr(addr, &amp;info) &amp;&amp; info.dli_saddr == addr &amp;&amp; info.dli_sname) ? info.dli_sname : <span class="enscript-string">"???"</span>;
#<span class="enscript-reference">else</span>
#<span class="enscript-reference">error</span> <span class="enscript-variable-name">Unknown</span> <span class="enscript-variable-name">or</span> <span class="enscript-variable-name">unspecified</span> <span class="enscript-variable-name">DEPLOYMENT_TARGET</span>
#<span class="enscript-reference">endif</span>
    CFStringRef result = CFStringCreateWithFormat(kCFAllocatorSystemDefault, NULL, CFSTR(<span class="enscript-string">"&lt;CFRunLoopTimer %p [%p]&gt;{valid = %s, interval = %0.09g, next fire date = %0.09g, callout = %s (%p), context = %@}"</span>), cf, CFGetAllocator(rlt), __CFIsValid(rlt) ? <span class="enscript-string">"Yes"</span> : <span class="enscript-string">"No"</span>, rlt-&gt;_interval, rlt-&gt;_nextFireDate, name, addr, contextDesc);
    CFRelease(contextDesc);
    <span class="enscript-keyword">return</span> result;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">__CFRunLoopTimerDeallocate</span>(CFTypeRef cf) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
<span class="enscript-comment">//CFLog(6, CFSTR("__CFRunLoopTimerDeallocate(%p)"), cf);
</span>    CFRunLoopTimerRef rlt = (CFRunLoopTimerRef)cf;
    __CFRunLoopTimerSetDeallocating(rlt);
    CFRunLoopTimerInvalidate(rlt);	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CFRelease(rlt-&gt;_rlModes);
    rlt-&gt;_rlModes = NULL;
    pthread_mutex_destroy(&amp;rlt-&gt;_lock);
}

<span class="enscript-type">static</span> <span class="enscript-type">const</span> CFRuntimeClass __CFRunLoopTimerClass = {
    0,
    <span class="enscript-string">"CFRunLoopTimer"</span>,
    NULL,      <span class="enscript-comment">// init
</span>    NULL,      <span class="enscript-comment">// copy
</span>    __CFRunLoopTimerDeallocate,
    NULL,	<span class="enscript-comment">// equal
</span>    NULL,
    NULL,      <span class="enscript-comment">// 
</span>    __CFRunLoopTimerCopyDescription
};

__private_extern__ <span class="enscript-type">void</span> __CFRunLoopTimerInitialize(<span class="enscript-type">void</span>) {
    __kCFRunLoopTimerTypeID = _CFRuntimeRegisterClass(&amp;__CFRunLoopTimerClass);
}

CFTypeID <span class="enscript-function-name">CFRunLoopTimerGetTypeID</span>(<span class="enscript-type">void</span>) {
    <span class="enscript-keyword">return</span> __kCFRunLoopTimerTypeID;
}

CFRunLoopTimerRef <span class="enscript-function-name">CFRunLoopTimerCreate</span>(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order, CFRunLoopTimerCallBack callout, CFRunLoopTimerContext *context) {
    CHECK_FOR_FORK();    
    CFRunLoopTimerRef memory;
    UInt32 size;
    size = <span class="enscript-keyword">sizeof</span>(<span class="enscript-type">struct</span> __CFRunLoopTimer) - <span class="enscript-keyword">sizeof</span>(CFRuntimeBase);
    memory = (CFRunLoopTimerRef)_CFRuntimeCreateInstance(allocator, __kCFRunLoopTimerTypeID, size, NULL);
    <span class="enscript-keyword">if</span> (NULL == memory) {
	<span class="enscript-keyword">return</span> NULL;
    }
    __CFSetValid(memory);
    __CFRunLoopTimerUnsetFiring(memory);
    __CFRunLoopLockInit(&amp;memory-&gt;_lock);
    memory-&gt;_runLoop = NULL;
    memory-&gt;_rlModes = CFSetCreateMutable(kCFAllocatorSystemDefault, 0, &amp;kCFTypeSetCallBacks);
    memory-&gt;_order = order;
    <span class="enscript-keyword">if</span> (interval &lt; 0.0) interval = 0.0;
    memory-&gt;_interval = interval;
    <span class="enscript-keyword">if</span> (TIMER_DATE_LIMIT &lt; fireDate) fireDate = TIMER_DATE_LIMIT;
    memory-&gt;_nextFireDate = fireDate;
    memory-&gt;_fireTSR = 0LL;
    int64_t now2 = (int64_t)mach_absolute_time();
    CFAbsoluteTime now1 = CFAbsoluteTimeGetCurrent();
    <span class="enscript-keyword">if</span> (fireDate &lt; now1) {
	memory-&gt;_fireTSR = now2;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (TIMER_INTERVAL_LIMIT &lt; fireDate - now1) {
	memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);
    } <span class="enscript-keyword">else</span> {
	memory-&gt;_fireTSR = now2 + __CFTimeIntervalToTSR(fireDate - now1);
    }
    memory-&gt;_callout = callout;
    <span class="enscript-keyword">if</span> (NULL != context) {
	<span class="enscript-keyword">if</span> (context-&gt;retain) {
	    memory-&gt;_context.info = (<span class="enscript-type">void</span> *)context-&gt;retain(context-&gt;info);
	} <span class="enscript-keyword">else</span> {
	    memory-&gt;_context.info = context-&gt;info;
	}
	memory-&gt;_context.retain = context-&gt;retain;
	memory-&gt;_context.release = context-&gt;release;
	memory-&gt;_context.copyDescription = context-&gt;copyDescription;
    } <span class="enscript-keyword">else</span> {
	memory-&gt;_context.info = 0;
	memory-&gt;_context.retain = 0;
	memory-&gt;_context.release = 0;
	memory-&gt;_context.copyDescription = 0;
    }
    <span class="enscript-keyword">return</span> memory;
}

<span class="enscript-type">static</span> <span class="enscript-type">void</span> <span class="enscript-function-name">_runLoopTimerWithBlockContext</span>(CFRunLoopTimerRef timer, <span class="enscript-type">void</span> *opaqueBlock) {
    <span class="enscript-type">typedef</span> <span class="enscript-type">void</span> (^timer_block_t) (CFRunLoopTimerRef timer);
    timer_block_t block = (timer_block_t)opaqueBlock;
    block(timer);
}

CFRunLoopTimerRef <span class="enscript-function-name">CFRunLoopTimerCreateWithHandler</span>(CFAllocatorRef allocator, CFAbsoluteTime fireDate, CFTimeInterval interval, CFOptionFlags flags, CFIndex order,
						<span class="enscript-type">void</span> (^block) (CFRunLoopTimerRef timer)) {
    
    CFRunLoopTimerContext blockContext;
    blockContext.version = 0;
    blockContext.info = (<span class="enscript-type">void</span> *)block;
    blockContext.retain = (<span class="enscript-type">const</span> <span class="enscript-type">void</span> *(*)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *info))_Block_copy;
    blockContext.release = (<span class="enscript-type">void</span> (*)(<span class="enscript-type">const</span> <span class="enscript-type">void</span> *info))_Block_release;
    blockContext.copyDescription = NULL;
    <span class="enscript-keyword">return</span> CFRunLoopTimerCreate(allocator, fireDate, interval, flags, order, _runLoopTimerWithBlockContext, &amp;blockContext);
}

CFAbsoluteTime <span class="enscript-function-name">CFRunLoopTimerGetNextFireDate</span>(CFRunLoopTimerRef rlt) {
    CHECK_FOR_FORK();
    CF_OBJC_FUNCDISPATCH0(__kCFRunLoopTimerTypeID, CFAbsoluteTime, rlt, <span class="enscript-string">"_cffireTime"</span>);
    __CFGenericValidateType(rlt, __kCFRunLoopTimerTypeID);
    CFAbsoluteTime at = 0.0;
    __CFRunLoopTimerLock(rlt);
    __CFRunLoopTimerFireTSRLock();
    <span class="enscript-keyword">if</span> (__CFIsValid(rlt)) {
        at = rlt-&gt;_nextFireDate;
    }
    __CFRunLoopTimerFireTSRUnlock();
    __CFRunLoopTimerUnlock(rlt);
    <span class="enscript-keyword">return</span> at;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopTimerSetNextFireDate</span>(CFRunLoopTimerRef rlt, CFAbsoluteTime fireDate) {
    CHECK_FOR_FORK();
    <span class="enscript-keyword">if</span> (!__CFIsValid(rlt)) <span class="enscript-keyword">return</span>;
    <span class="enscript-keyword">if</span> (TIMER_DATE_LIMIT &lt; fireDate) fireDate = TIMER_DATE_LIMIT;
    int64_t nextFireTSR = 0LL;
    int64_t now2 = (int64_t)mach_absolute_time();
    CFAbsoluteTime now1 = CFAbsoluteTimeGetCurrent();
    <span class="enscript-keyword">if</span> (fireDate &lt; now1) {
	nextFireTSR = now2;
    } <span class="enscript-keyword">else</span> <span class="enscript-keyword">if</span> (TIMER_INTERVAL_LIMIT &lt; fireDate - now1) {
	nextFireTSR = now2 + __CFTimeIntervalToTSR(TIMER_INTERVAL_LIMIT);
    } <span class="enscript-keyword">else</span> {
	nextFireTSR = now2 + __CFTimeIntervalToTSR(fireDate - now1);
    }
    __CFRunLoopTimerLock(rlt);
    <span class="enscript-keyword">if</span> (NULL != rlt-&gt;_runLoop) {
        CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes);
        STACK_BUFFER_DECL(CFTypeRef, modes, cnt);
        CFSetGetValues(rlt-&gt;_rlModes, (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **)modes);
        <span class="enscript-comment">// To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up
</span>        <span class="enscript-comment">// towards the run loop from a source, the timer has to be
</span>        <span class="enscript-comment">// unlocked, which means we have to protect from object
</span>        <span class="enscript-comment">// invalidation, although that's somewhat expensive.
</span>        <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
            CFRetain(modes[idx]);
        }
        CFRunLoopRef rl = (CFRunLoopRef)CFRetain(rlt-&gt;_runLoop);
        __CFRunLoopTimerUnlock(rlt);
        __CFRunLoopLock(rl);
        <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
	    CFStringRef name = (CFStringRef)modes[idx];
            modes[idx] = __CFRunLoopFindMode(rl, name, false);
	    CFRelease(name);
        }
        __CFRunLoopTimerFireTSRLock();
	rlt-&gt;_fireTSR = nextFireTSR;
        rlt-&gt;_nextFireDate = fireDate;
        <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
	    CFRunLoopModeRef rlm = (CFRunLoopModeRef)modes[idx];
            <span class="enscript-keyword">if</span> (rlm) {
                __CFRepositionTimerInMode(rlm, rlt, true);
            }
        }
        __CFRunLoopTimerFireTSRUnlock();
        <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
            __CFRunLoopModeUnlock((CFRunLoopModeRef)modes[idx]);
        }
        __CFRunLoopUnlock(rl);
        <span class="enscript-comment">// This is setting the date of a timer, not a direct
</span>        <span class="enscript-comment">// interaction with a run loop, so we'll do a wakeup
</span>        <span class="enscript-comment">// (which may be costly) for the caller, just in case.
</span>        <span class="enscript-comment">// (And useful for binary compatibility with older
</span>        <span class="enscript-comment">// code used to the older timer implementation.)
</span>        <span class="enscript-keyword">if</span> (rl != CFRunLoopGetCurrent()) CFRunLoopWakeUp(rl);
        CFRelease(rl);
     } <span class="enscript-keyword">else</span> {
        __CFRunLoopTimerFireTSRLock();
	rlt-&gt;_fireTSR = nextFireTSR;
        rlt-&gt;_nextFireDate = fireDate;
        __CFRunLoopTimerFireTSRUnlock();
         __CFRunLoopTimerUnlock(rlt);
     }
}

CFTimeInterval <span class="enscript-function-name">CFRunLoopTimerGetInterval</span>(CFRunLoopTimerRef rlt) {
    CHECK_FOR_FORK();
    CF_OBJC_FUNCDISPATCH0(__kCFRunLoopTimerTypeID, CFTimeInterval, rlt, <span class="enscript-string">"timeInterval"</span>);
    __CFGenericValidateType(rlt, __kCFRunLoopTimerTypeID);
    <span class="enscript-keyword">return</span> rlt-&gt;_interval;
}

Boolean <span class="enscript-function-name">CFRunLoopTimerDoesRepeat</span>(CFRunLoopTimerRef rlt) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rlt, __kCFRunLoopTimerTypeID);
    <span class="enscript-keyword">return</span> (0.0 &lt; rlt-&gt;_interval);
}

CFIndex <span class="enscript-function-name">CFRunLoopTimerGetOrder</span>(CFRunLoopTimerRef rlt) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rlt, __kCFRunLoopTimerTypeID);
    <span class="enscript-keyword">return</span> rlt-&gt;_order;
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopTimerInvalidate</span>(CFRunLoopTimerRef rlt) {	<span class="enscript-comment">/* DOES CALLOUT */</span>
    CHECK_FOR_FORK();
    CF_OBJC_FUNCDISPATCH0(__kCFRunLoopTimerTypeID, <span class="enscript-type">void</span>, rlt, <span class="enscript-string">"invalidate"</span>);
    __CFGenericValidateType(rlt, __kCFRunLoopTimerTypeID);
    __CFRunLoopTimerLock(rlt);
    <span class="enscript-keyword">if</span> (!__CFRunLoopTimerIsDeallocating(rlt)) {
        CFRetain(rlt);
    }
    <span class="enscript-keyword">if</span> (__CFIsValid(rlt)) {
	CFRunLoopRef rl = rlt-&gt;_runLoop;
	<span class="enscript-type">void</span> *info = rlt-&gt;_context.info;
	rlt-&gt;_context.info = NULL;
	__CFUnsetValid(rlt);
	<span class="enscript-keyword">if</span> (NULL != rl) {
	    CFIndex cnt = CFSetGetCount(rlt-&gt;_rlModes);
	    STACK_BUFFER_DECL(CFStringRef, modes, cnt);
	    CFSetGetValues(rlt-&gt;_rlModes, (<span class="enscript-type">const</span> <span class="enscript-type">void</span> **)modes);
            <span class="enscript-comment">// To avoid A-&gt;B, B-&gt;A lock ordering issues when coming up
</span>            <span class="enscript-comment">// towards the run loop from a source, the timer has to be
</span>            <span class="enscript-comment">// unlocked, which means we have to protect from object
</span>            <span class="enscript-comment">// invalidation, although that's somewhat expensive.
</span>            <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
                CFRetain(modes[idx]);
            }
            CFRetain(rl);
            __CFRunLoopTimerUnlock(rlt);
            <span class="enscript-comment">// CFRunLoopRemoveTimer will lock the run loop while it
</span>            <span class="enscript-comment">// needs that, but we also lock it out here to keep
</span>            <span class="enscript-comment">// changes from occurring for this whole sequence.
</span>            __CFRunLoopLock(rl);
	    <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
		CFRunLoopRemoveTimer(rl, rlt, modes[idx]);
	    }
	    CFRunLoopRemoveTimer(rl, rlt, kCFRunLoopCommonModes);
            __CFRunLoopUnlock(rl);
            <span class="enscript-keyword">for</span> (CFIndex idx = 0; idx &lt; cnt; idx++) {
                CFRelease(modes[idx]);
            }
            CFRelease(rl);
            __CFRunLoopTimerLock(rlt);
	}
	<span class="enscript-keyword">if</span> (NULL != rlt-&gt;_context.release) {
	    rlt-&gt;_context.release(info);	<span class="enscript-comment">/* CALLOUT */</span>
	}
    }
    __CFRunLoopTimerUnlock(rlt);
    <span class="enscript-keyword">if</span> (!__CFRunLoopTimerIsDeallocating(rlt)) {
        CFRelease(rlt);
    }
}

Boolean <span class="enscript-function-name">CFRunLoopTimerIsValid</span>(CFRunLoopTimerRef rlt) {
    CHECK_FOR_FORK();
    CF_OBJC_FUNCDISPATCH0(__kCFRunLoopTimerTypeID, Boolean, rlt, <span class="enscript-string">"isValid"</span>);
    __CFGenericValidateType(rlt, __kCFRunLoopTimerTypeID);
    <span class="enscript-keyword">return</span> __CFIsValid(rlt);
}

<span class="enscript-type">void</span> <span class="enscript-function-name">CFRunLoopTimerGetContext</span>(CFRunLoopTimerRef rlt, CFRunLoopTimerContext *context) {
    CHECK_FOR_FORK();
    __CFGenericValidateType(rlt, __kCFRunLoopTimerTypeID);
    CFAssert1(0 == context-&gt;version, __kCFLogAssertion, <span class="enscript-string">"%s(): context version not initialized to 0"</span>, __PRETTY_FUNCTION__);
    *context = rlt-&gt;_context;
}

</pre>
<hr>
</body></html>
